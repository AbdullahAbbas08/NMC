//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class SwaggerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5200";
    }

    apiCommitteeGetByIdGet(id: number | undefined): Observable<CommitteeList> {
        let url_ = this.baseUrl + "/api/Committee/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeGetByIdGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommitteeList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommitteeList>;
        }));
    }

    protected processApiCommitteeGetByIdGet(response: HttpResponseBase): Observable<CommitteeList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommitteeList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCommitteeGetCommiteeDataEntriesGet(id: number | undefined): Observable<MainUserNameIDList[]> {
        let url_ = this.baseUrl + "/api/Committee/GetCommiteeDataEntries?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeGetCommiteeDataEntriesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeGetCommiteeDataEntriesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainUserNameIDList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainUserNameIDList[]>;
        }));
    }

    protected processApiCommitteeGetCommiteeDataEntriesGet(response: HttpResponseBase): Observable<MainUserNameIDList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MainUserNameIDList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCommitteeGetAllCommitteesGet(): Observable<CommitteeIdName[]> {
        let url_ = this.baseUrl + "/api/Committee/getAllCommittees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeGetAllCommitteesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeGetAllCommitteesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommitteeIdName[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommitteeIdName[]>;
        }));
    }

    protected processApiCommitteeGetAllCommitteesGet(response: HttpResponseBase): Observable<CommitteeIdName[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommitteeIdName.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCommitteeGetAllCommitteesByBranchIdGet(branchId: number | undefined): Observable<CommitteeIdName[]> {
        let url_ = this.baseUrl + "/api/Committee/getAllCommitteesByBranchId?";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeGetAllCommitteesByBranchIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeGetAllCommitteesByBranchIdGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommitteeIdName[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommitteeIdName[]>;
        }));
    }

    protected processApiCommitteeGetAllCommitteesByBranchIdGet(response: HttpResponseBase): Observable<CommitteeIdName[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommitteeIdName.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCommitteeGetAllCustomGet(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<ViewerPaginationOfCommitteeList> {
        let url_ = this.baseUrl + "/api/Committee/GetAllCustom?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeGetAllCustomGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeGetAllCustomGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfCommitteeList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfCommitteeList>;
        }));
    }

    protected processApiCommitteeGetAllCustomGet(response: HttpResponseBase): Observable<ViewerPaginationOfCommitteeList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfCommitteeList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCommitteeGetCommitteeOrdersPost(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined, committeeId: number | null | undefined, departmentId: number | null | undefined, orderStatus: OrderStatus[]): Observable<ViewerPaginationOfOrderListDto> {
        let url_ = this.baseUrl + "/api/Committee/getCommitteeOrders?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (committeeId !== undefined && committeeId !== null)
            url_ += "committeeId=" + encodeURIComponent("" + committeeId) + "&";
        if (departmentId !== undefined && departmentId !== null)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(orderStatus);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeGetCommitteeOrdersPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeGetCommitteeOrdersPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfOrderListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfOrderListDto>;
        }));
    }

    protected processApiCommitteeGetCommitteeOrdersPost(response: HttpResponseBase): Observable<ViewerPaginationOfOrderListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfOrderListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCommitteeGetOrdersForPreviewPost(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined, committeeId: number | null | undefined, departmentId: number | null | undefined, orderStatus: OrderStatus[]): Observable<ViewerPaginationOfOrderListDto> {
        let url_ = this.baseUrl + "/api/Committee/getOrdersForPreview?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (committeeId !== undefined && committeeId !== null)
            url_ += "committeeId=" + encodeURIComponent("" + committeeId) + "&";
        if (departmentId !== undefined && departmentId !== null)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(orderStatus);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeGetOrdersForPreviewPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeGetOrdersForPreviewPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfOrderListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfOrderListDto>;
        }));
    }

    protected processApiCommitteeGetOrdersForPreviewPost(response: HttpResponseBase): Observable<ViewerPaginationOfOrderListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfOrderListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCommitteeGetFinishedOrdersPost(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined, committeeId: number | null | undefined, departmentId: number | null | undefined): Observable<ViewerPaginationOfOrderListDto> {
        let url_ = this.baseUrl + "/api/Committee/getFinishedOrders?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (committeeId !== undefined && committeeId !== null)
            url_ += "committeeId=" + encodeURIComponent("" + committeeId) + "&";
        if (departmentId !== undefined && departmentId !== null)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeGetFinishedOrdersPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeGetFinishedOrdersPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfOrderListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfOrderListDto>;
        }));
    }

    protected processApiCommitteeGetFinishedOrdersPost(response: HttpResponseBase): Observable<ViewerPaginationOfOrderListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfOrderListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCommitteeInsertPost(model: CommitteeDto): Observable<GenericResultOfCommittee> {
        let url_ = this.baseUrl + "/api/Committee/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResultOfCommittee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResultOfCommittee>;
        }));
    }

    protected processApiCommitteeInsertPost(response: HttpResponseBase): Observable<GenericResultOfCommittee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResultOfCommittee.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCommitteeDeletePost(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Committee/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiCommitteeDeletePost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiCommitteeTransfereOrdersPost(orderTransfere: OrderTransfereDTO): Observable<OrderTransfereDTO> {
        let url_ = this.baseUrl + "/api/Committee/TransfereOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(orderTransfere);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiCommitteeTransfereOrdersPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCommitteeTransfereOrdersPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderTransfereDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderTransfereDTO>;
        }));
    }

    protected processApiCommitteeTransfereOrdersPost(response: HttpResponseBase): Observable<OrderTransfereDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderTransfereDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiIslamRecognitionWayGetByIdGet(id: number | undefined): Observable<IsslamRecognition> {
        let url_ = this.baseUrl + "/api/IslamRecognitionWay/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiIslamRecognitionWayGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiIslamRecognitionWayGetByIdGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsslamRecognition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsslamRecognition>;
        }));
    }

    protected processApiIslamRecognitionWayGetByIdGet(response: HttpResponseBase): Observable<IsslamRecognition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsslamRecognition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiIslamRecognitionWayGetAllCustomGet(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<ViewerPaginationOfIsslamRecognitionDto> {
        let url_ = this.baseUrl + "/api/IslamRecognitionWay/GetAllCustom?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiIslamRecognitionWayGetAllCustomGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiIslamRecognitionWayGetAllCustomGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfIsslamRecognitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfIsslamRecognitionDto>;
        }));
    }

    protected processApiIslamRecognitionWayGetAllCustomGet(response: HttpResponseBase): Observable<ViewerPaginationOfIsslamRecognitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfIsslamRecognitionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiIslamRecognitionWayRecognitionWayPost(model: IsslamRecognition): Observable<GenericResultOfIsslamRecognition> {
        let url_ = this.baseUrl + "/api/IslamRecognitionWay/RecognitionWay";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiIslamRecognitionWayRecognitionWayPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiIslamRecognitionWayRecognitionWayPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResultOfIsslamRecognition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResultOfIsslamRecognition>;
        }));
    }

    protected processApiIslamRecognitionWayRecognitionWayPost(response: HttpResponseBase): Observable<GenericResultOfIsslamRecognition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResultOfIsslamRecognition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiIslamRecognitionWayDeletePost(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/IslamRecognitionWay/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiIslamRecognitionWayDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiIslamRecognitionWayDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiIslamRecognitionWayDeletePost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLocalizationJsonGet(culture: string | null): Observable<string> {
        let url_ = this.baseUrl + "/api/Localization/json/{culture}";
        if (culture === undefined || culture === null)
            throw new Error("The parameter 'culture' must be defined.");
        url_ = url_.replace("{culture}", encodeURIComponent("" + culture));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationJsonGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationJsonGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processApiLocalizationJsonGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLocalizationGetLocalizationGet(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<ViewerPaginationOfLocalizationDetailsDTO> {
        let url_ = this.baseUrl + "/api/Localization/getLocalization?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationGetLocalizationGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationGetLocalizationGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfLocalizationDetailsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfLocalizationDetailsDTO>;
        }));
    }

    protected processApiLocalizationGetLocalizationGet(response: HttpResponseBase): Observable<ViewerPaginationOfLocalizationDetailsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfLocalizationDetailsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLocalizationGetLocalizationByIdGet(id: number | undefined): Observable<LocalizationDetailsDTO> {
        let url_ = this.baseUrl + "/api/Localization/getLocalizationById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationGetLocalizationByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationGetLocalizationByIdGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocalizationDetailsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocalizationDetailsDTO>;
        }));
    }

    protected processApiLocalizationGetLocalizationByIdGet(response: HttpResponseBase): Observable<LocalizationDetailsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocalizationDetailsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLocalizationUpdateTranslationPost(id: number | undefined, localization: LocalizationDetailsDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Localization/updateTranslation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(localization);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationUpdateTranslationPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationUpdateTranslationPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiLocalizationUpdateTranslationPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLocalizationDeleteTranslationPost(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Localization/deleteTranslation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationDeleteTranslationPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationDeleteTranslationPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiLocalizationDeleteTranslationPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLocalizationAddTranslationPost(localization: LocalizationDetailsDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Localization/addTranslation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(localization);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationAddTranslationPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationAddTranslationPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiLocalizationAddTranslationPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLocalizationAddBulkTranslationPost(localizations: LocalizationDetailsDTO[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Localization/addBulkTranslation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(localizations);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationAddBulkTranslationPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationAddBulkTranslationPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiLocalizationAddBulkTranslationPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLocalizationGetLastUpDateTimeGet(): Observable<Date> {
        let url_ = this.baseUrl + "/api/Localization/GetLastUpDateTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLocalizationGetLastUpDateTimeGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLocalizationGetLastUpDateTimeGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Date>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Date>;
        }));
    }

    protected processApiLocalizationGetLastUpDateTimeGet(response: HttpResponseBase): Observable<Date> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? new Date(resultData200.toString()) : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetAllDepartmentsGet(): Observable<DepartmentDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetAllDepartments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetAllDepartmentsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetAllDepartmentsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentDto[]>;
        }));
    }

    protected processApiLookupGetAllDepartmentsGet(response: HttpResponseBase): Observable<DepartmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetAllBranchsGet(): Observable<BranshDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetAllBranchs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetAllBranchsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetAllBranchsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranshDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranshDto[]>;
        }));
    }

    protected processApiLookupGetAllBranchsGet(response: HttpResponseBase): Observable<BranshDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BranshDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetAllDepartmentsPaginatedGet(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<ViewerPaginationOfDepartmentDto> {
        let url_ = this.baseUrl + "/api/Lookup/GetAllDepartmentsPaginated?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetAllDepartmentsPaginatedGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetAllDepartmentsPaginatedGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfDepartmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfDepartmentDto>;
        }));
    }

    protected processApiLookupGetAllDepartmentsPaginatedGet(response: HttpResponseBase): Observable<ViewerPaginationOfDepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfDepartmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetAllBranchsPaginatedGet(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<ViewerPaginationOfBranshListDto> {
        let url_ = this.baseUrl + "/api/Lookup/GetAllBranchsPaginated?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetAllBranchsPaginatedGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetAllBranchsPaginatedGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfBranshListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfBranshListDto>;
        }));
    }

    protected processApiLookupGetAllBranchsPaginatedGet(response: HttpResponseBase): Observable<ViewerPaginationOfBranshListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfBranshListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetResidencePalcePaginatedGet(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<ViewerPaginationOfResidenceIssuePlace> {
        let url_ = this.baseUrl + "/api/Lookup/GetResidencePalcePaginated?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetResidencePalcePaginatedGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetResidencePalcePaginatedGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfResidenceIssuePlace>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfResidenceIssuePlace>;
        }));
    }

    protected processApiLookupGetResidencePalcePaginatedGet(response: HttpResponseBase): Observable<ViewerPaginationOfResidenceIssuePlace> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfResidenceIssuePlace.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetResidencePalceGet(): Observable<ResidenceIssuePlace[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetResidencePalce";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetResidencePalceGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetResidencePalceGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResidenceIssuePlace[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResidenceIssuePlace[]>;
        }));
    }

    protected processApiLookupGetResidencePalceGet(response: HttpResponseBase): Observable<ResidenceIssuePlace[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResidenceIssuePlace.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetPreshersPaginatedGet(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<ViewerPaginationOfPreacher> {
        let url_ = this.baseUrl + "/api/Lookup/GetPreshersPaginated?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetPreshersPaginatedGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetPreshersPaginatedGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfPreacher>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfPreacher>;
        }));
    }

    protected processApiLookupGetPreshersPaginatedGet(response: HttpResponseBase): Observable<ViewerPaginationOfPreacher> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfPreacher.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetPreshersGet(): Observable<Preacher[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetPreshers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetPreshersGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetPreshersGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Preacher[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Preacher[]>;
        }));
    }

    protected processApiLookupGetPreshersGet(response: HttpResponseBase): Observable<Preacher[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Preacher.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupSavePresherPost(model: Preacher): Observable<number> {
        let url_ = this.baseUrl + "/api/Lookup/SavePresher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupSavePresherPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupSavePresherPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processApiLookupSavePresherPost(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupSaveResidenceIssuePlacePost(model: ResidenceIssuePlace): Observable<number> {
        let url_ = this.baseUrl + "/api/Lookup/SaveResidenceIssuePlace";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupSaveResidenceIssuePlacePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupSaveResidenceIssuePlacePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processApiLookupSaveResidenceIssuePlacePost(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupRecognitionWaysGet(): Observable<IsslamRecognitionData[]> {
        let url_ = this.baseUrl + "/api/Lookup/RecognitionWays";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupRecognitionWaysGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupRecognitionWaysGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsslamRecognitionData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsslamRecognitionData[]>;
        }));
    }

    protected processApiLookupRecognitionWaysGet(response: HttpResponseBase): Observable<IsslamRecognitionData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IsslamRecognitionData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetCountriesGet(): Observable<Country[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetCountriesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetCountriesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country[]>;
        }));
    }

    protected processApiLookupGetCountriesGet(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Country.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetEducationalLevelsGet(): Observable<EducationalLevel[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetEducationalLevels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetEducationalLevelsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetEducationalLevelsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EducationalLevel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EducationalLevel[]>;
        }));
    }

    protected processApiLookupGetEducationalLevelsGet(response: HttpResponseBase): Observable<EducationalLevel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EducationalLevel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetReligionsGet(): Observable<Religion[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetReligions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetReligionsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetReligionsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Religion[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Religion[]>;
        }));
    }

    protected processApiLookupGetReligionsGet(response: HttpResponseBase): Observable<Religion[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Religion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetMainRolesGet(): Observable<MainRoleNameId[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetMainRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetMainRolesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetMainRolesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainRoleNameId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainRoleNameId[]>;
        }));
    }

    protected processApiLookupGetMainRolesGet(response: HttpResponseBase): Observable<MainRoleNameId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MainRoleNameId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetMainRolesDataEntryCommitteeMangerGet(): Observable<MainRoleNameId[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetMainRolesDataEntryCommitteeManger";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetMainRolesDataEntryCommitteeMangerGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetMainRolesDataEntryCommitteeMangerGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainRoleNameId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainRoleNameId[]>;
        }));
    }

    protected processApiLookupGetMainRolesDataEntryCommitteeMangerGet(response: HttpResponseBase): Observable<MainRoleNameId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MainRoleNameId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetAllMainRolesGet(): Observable<MainRoleNameId[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetAllMainRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetAllMainRolesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetAllMainRolesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainRoleNameId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainRoleNameId[]>;
        }));
    }

    protected processApiLookupGetAllMainRolesGet(response: HttpResponseBase): Observable<MainRoleNameId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MainRoleNameId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetCommitteeMainRolesGet(): Observable<MainRoleNameId[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetCommitteeMainRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetCommitteeMainRolesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetCommitteeMainRolesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainRoleNameId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainRoleNameId[]>;
        }));
    }

    protected processApiLookupGetCommitteeMainRolesGet(response: HttpResponseBase): Observable<MainRoleNameId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MainRoleNameId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetAllUsersGet(): Observable<CommitteeRoleViewModel[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetAllUsersGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetAllUsersGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommitteeRoleViewModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommitteeRoleViewModel[]>;
        }));
    }

    protected processApiLookupGetAllUsersGet(response: HttpResponseBase): Observable<CommitteeRoleViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommitteeRoleViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetRelatedUsersGet(entryId: number | undefined): Observable<NameIdViewModel[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetRelatedUsers?";
        if (entryId === null)
            throw new Error("The parameter 'entryId' cannot be null.");
        else if (entryId !== undefined)
            url_ += "EntryId=" + encodeURIComponent("" + entryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetRelatedUsersGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetRelatedUsersGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameIdViewModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameIdViewModel[]>;
        }));
    }

    protected processApiLookupGetRelatedUsersGet(response: HttpResponseBase): Observable<NameIdViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameIdViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetADUsersGet(): Observable<CommitteeRoleViewModel[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetADUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetADUsersGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetADUsersGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommitteeRoleViewModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommitteeRoleViewModel[]>;
        }));
    }

    protected processApiLookupGetADUsersGet(response: HttpResponseBase): Observable<CommitteeRoleViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommitteeRoleViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiLookupGetAllNegotiatedUsersGet(): Observable<CommitteeRoleViewModel[]> {
        let url_ = this.baseUrl + "/api/Lookup/GetAllNegotiatedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiLookupGetAllNegotiatedUsersGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiLookupGetAllNegotiatedUsersGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommitteeRoleViewModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommitteeRoleViewModel[]>;
        }));
    }

    protected processApiLookupGetAllNegotiatedUsersGet(response: HttpResponseBase): Observable<CommitteeRoleViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommitteeRoleViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeGet(): Observable<MuslimeDto[]> {
        let url_ = this.baseUrl + "/api/Muslime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MuslimeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MuslimeDto[]>;
        }));
    }

    protected processApiMuslimeGet(response: HttpResponseBase): Observable<MuslimeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MuslimeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeGetDataGet(orderCode: string | null | undefined): Observable<MuslimeDto> {
        let url_ = this.baseUrl + "/api/Muslime/getData?";
        if (orderCode !== undefined && orderCode !== null)
            url_ += "OrderCode=" + encodeURIComponent("" + orderCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeGetDataGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeGetDataGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MuslimeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MuslimeDto>;
        }));
    }

    protected processApiMuslimeGetDataGet(response: HttpResponseBase): Observable<MuslimeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MuslimeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeGetDataForQueryPost(id: string | null | undefined): Observable<UserDataForVieweing> {
        let url_ = this.baseUrl + "/api/Muslime/getDataForQuery?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeGetDataForQueryPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeGetDataForQueryPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDataForVieweing>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDataForVieweing>;
        }));
    }

    protected processApiMuslimeGetDataForQueryPost(response: HttpResponseBase): Observable<UserDataForVieweing> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDataForVieweing.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeGetPersonalDataGet(muslimeId: number | undefined): Observable<PersonalDataDto> {
        let url_ = this.baseUrl + "/api/Muslime/getPersonalData?";
        if (muslimeId === null)
            throw new Error("The parameter 'muslimeId' cannot be null.");
        else if (muslimeId !== undefined)
            url_ += "MuslimeId=" + encodeURIComponent("" + muslimeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeGetPersonalDataGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeGetPersonalDataGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonalDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonalDataDto>;
        }));
    }

    protected processApiMuslimeGetPersonalDataGet(response: HttpResponseBase): Observable<PersonalDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonalDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeGetPersonalInformationGet(muslimeId: number | undefined): Observable<PersonalInformationDto> {
        let url_ = this.baseUrl + "/api/Muslime/getPersonalInformation?";
        if (muslimeId === null)
            throw new Error("The parameter 'muslimeId' cannot be null.");
        else if (muslimeId !== undefined)
            url_ += "MuslimeId=" + encodeURIComponent("" + muslimeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeGetPersonalInformationGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeGetPersonalInformationGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonalInformationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonalInformationDto>;
        }));
    }

    protected processApiMuslimeGetPersonalInformationGet(response: HttpResponseBase): Observable<PersonalInformationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonalInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeGetContactDataGet(muslimeId: number | undefined): Observable<ContactAndInfoDataViewModel> {
        let url_ = this.baseUrl + "/api/Muslime/getContactData?";
        if (muslimeId === null)
            throw new Error("The parameter 'muslimeId' cannot be null.");
        else if (muslimeId !== undefined)
            url_ += "MuslimeId=" + encodeURIComponent("" + muslimeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeGetContactDataGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeGetContactDataGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactAndInfoDataViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactAndInfoDataViewModel>;
        }));
    }

    protected processApiMuslimeGetContactDataGet(response: HttpResponseBase): Observable<ContactAndInfoDataViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactAndInfoDataViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeGetFamilyAndWorkGet(muslimeId: number | undefined): Observable<FamilyAndWorkDto> {
        let url_ = this.baseUrl + "/api/Muslime/getFamilyAndWork?";
        if (muslimeId === null)
            throw new Error("The parameter 'muslimeId' cannot be null.");
        else if (muslimeId !== undefined)
            url_ += "MuslimeId=" + encodeURIComponent("" + muslimeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeGetFamilyAndWorkGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeGetFamilyAndWorkGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyAndWorkDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyAndWorkDto>;
        }));
    }

    protected processApiMuslimeGetFamilyAndWorkGet(response: HttpResponseBase): Observable<FamilyAndWorkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyAndWorkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeGetIslamRecognitionWayGet(muslimeId: number | undefined): Observable<IsslamRecognitionData[]> {
        let url_ = this.baseUrl + "/api/Muslime/getIslamRecognitionWay?";
        if (muslimeId === null)
            throw new Error("The parameter 'muslimeId' cannot be null.");
        else if (muslimeId !== undefined)
            url_ += "MuslimeId=" + encodeURIComponent("" + muslimeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeGetIslamRecognitionWayGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeGetIslamRecognitionWayGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsslamRecognitionData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsslamRecognitionData[]>;
        }));
    }

    protected processApiMuslimeGetIslamRecognitionWayGet(response: HttpResponseBase): Observable<IsslamRecognitionData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IsslamRecognitionData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeGetattachmentDtoGet(muslimeId: number | undefined): Observable<AttachmentDto> {
        let url_ = this.baseUrl + "/api/Muslime/getattachmentDto?";
        if (muslimeId === null)
            throw new Error("The parameter 'muslimeId' cannot be null.");
        else if (muslimeId !== undefined)
            url_ += "MuslimeId=" + encodeURIComponent("" + muslimeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeGetattachmentDtoGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeGetattachmentDtoGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentDto>;
        }));
    }

    protected processApiMuslimeGetattachmentDtoGet(response: HttpResponseBase): Observable<AttachmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeCreatePersonalDataPost(model: PersonalDataDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Muslime/CreatePersonalData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeCreatePersonalDataPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeCreatePersonalDataPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processApiMuslimeCreatePersonalDataPost(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeCreatePersonalInformationPost(model: PersonalInformationDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Muslime/CreatePersonalInformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeCreatePersonalInformationPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeCreatePersonalInformationPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processApiMuslimeCreatePersonalInformationPost(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeCreateContactAndInfoDataPost(model: ContactAndInfoDataViewModel): Observable<number> {
        let url_ = this.baseUrl + "/api/Muslime/CreateContactAndInfoData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeCreateContactAndInfoDataPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeCreateContactAndInfoDataPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processApiMuslimeCreateContactAndInfoDataPost(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeCreateFamilyAndWorkDtoPost(model: FamilyAndWorkDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Muslime/CreateFamilyAndWorkDto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeCreateFamilyAndWorkDtoPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeCreateFamilyAndWorkDtoPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processApiMuslimeCreateFamilyAndWorkDtoPost(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeCreateIslamRecognitionWaysPost(model: IslamRecognitionWayDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Muslime/CreateIslamRecognitionWays";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeCreateIslamRecognitionWaysPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeCreateIslamRecognitionWaysPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processApiMuslimeCreateIslamRecognitionWaysPost(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeInsertAttachmentPost(muslimeId: number | undefined, personal: FileParameter | null | undefined, accomodation: FileParameter | null | undefined, passport: FileParameter | null | undefined, _Personal: string | null | undefined, _Accomodation: string | null | undefined, _Passport: string | null | undefined, iD: number | undefined, createdBy: number | null | undefined, createdOn: Date | null | undefined, updatedBy: number | null | undefined, updatedOn: Date | null | undefined, deletedBy: number | null | undefined, deletedOn: Date | null | undefined): Observable<CustomeResponse> {
        let url_ = this.baseUrl + "/api/Muslime/InsertAttachment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (muslimeId === null || muslimeId === undefined)
            throw new Error("The parameter 'muslimeId' cannot be null.");
        else
            content_.append("MuslimeId", muslimeId.toString());
        if (personal !== null && personal !== undefined)
            content_.append("Personal", personal.data, personal.fileName ? personal.fileName : "Personal");
        if (accomodation !== null && accomodation !== undefined)
            content_.append("Accomodation", accomodation.data, accomodation.fileName ? accomodation.fileName : "Accomodation");
        if (passport !== null && passport !== undefined)
            content_.append("Passport", passport.data, passport.fileName ? passport.fileName : "Passport");
        if (_Personal !== null && _Personal !== undefined)
            content_.append("_Personal", _Personal.toString());
        if (_Accomodation !== null && _Accomodation !== undefined)
            content_.append("_Accomodation", _Accomodation.toString());
        if (_Passport !== null && _Passport !== undefined)
            content_.append("_Passport", _Passport.toString());
        if (iD === null || iD === undefined)
            throw new Error("The parameter 'iD' cannot be null.");
        else
            content_.append("ID", iD.toString());
        if (createdBy !== null && createdBy !== undefined)
            content_.append("CreatedBy", createdBy.toString());
        if (createdOn !== null && createdOn !== undefined)
            content_.append("CreatedOn", createdOn.toJSON());
        if (updatedBy !== null && updatedBy !== undefined)
            content_.append("UpdatedBy", updatedBy.toString());
        if (updatedOn !== null && updatedOn !== undefined)
            content_.append("UpdatedOn", updatedOn.toJSON());
        if (deletedBy !== null && deletedBy !== undefined)
            content_.append("DeletedBy", deletedBy.toString());
        if (deletedOn !== null && deletedOn !== undefined)
            content_.append("DeletedOn", deletedOn.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeInsertAttachmentPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeInsertAttachmentPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomeResponse>;
        }));
    }

    protected processApiMuslimeInsertAttachmentPost(response: HttpResponseBase): Observable<CustomeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeChangeOrderStatePost(orderCode: string | null | undefined, orderStatus: OrderStatus | undefined, orderStage: OrderStage | undefined, description: string | null | undefined): Observable<CustomeResponse> {
        let url_ = this.baseUrl + "/api/Muslime/ChangeOrderState?";
        if (orderCode !== undefined && orderCode !== null)
            url_ += "OrderCode=" + encodeURIComponent("" + orderCode) + "&";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            url_ += "orderStatus=" + encodeURIComponent("" + orderStatus) + "&";
        if (orderStage === null)
            throw new Error("The parameter 'orderStage' cannot be null.");
        else if (orderStage !== undefined)
            url_ += "orderStage=" + encodeURIComponent("" + orderStage) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeChangeOrderStatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeChangeOrderStatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomeResponse>;
        }));
    }

    protected processApiMuslimeChangeOrderStatePost(response: HttpResponseBase): Observable<CustomeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimePrintCardGet(code: string | null | undefined): Observable<PrintCardView> {
        let url_ = this.baseUrl + "/api/Muslime/PrintCard?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimePrintCardGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimePrintCardGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrintCardView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrintCardView>;
        }));
    }

    protected processApiMuslimePrintCardGet(response: HttpResponseBase): Observable<PrintCardView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintCardView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeUpdateCardTawakkalnaPost(code: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Muslime/UpdateCardTawakkalna?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeUpdateCardTawakkalnaPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeUpdateCardTawakkalnaPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiMuslimeUpdateCardTawakkalnaPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeAddTawakkalnaCardPost(code: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Muslime/AddTawakkalnaCard?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeAddTawakkalnaCardPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeAddTawakkalnaCardPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiMuslimeAddTawakkalnaCardPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiMuslimeDeleteCardTawakkalnaPost(code: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Muslime/DeleteCardTawakkalna?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMuslimeDeleteCardTawakkalnaPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMuslimeDeleteCardTawakkalnaPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiMuslimeDeleteCardTawakkalnaPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiReportGetStatisticalsOrdersGet(branchID: number | null | undefined, committeeId: number | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<ViewerPaginationOfStatisticalsOrders> {
        let url_ = this.baseUrl + "/api/Report/getStatisticalsOrders?";
        if (branchID !== undefined && branchID !== null)
            url_ += "branchID=" + encodeURIComponent("" + branchID) + "&";
        if (committeeId !== undefined && committeeId !== null)
            url_ += "committeeId=" + encodeURIComponent("" + committeeId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiReportGetStatisticalsOrdersGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiReportGetStatisticalsOrdersGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfStatisticalsOrders>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfStatisticalsOrders>;
        }));
    }

    protected processApiReportGetStatisticalsOrdersGet(response: HttpResponseBase): Observable<ViewerPaginationOfStatisticalsOrders> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfStatisticalsOrders.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiSettingsGetSettingsGet(): Observable<Settings[]> {
        let url_ = this.baseUrl + "/api/Settings/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSettingsGetSettingsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSettingsGetSettingsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Settings[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Settings[]>;
        }));
    }

    protected processApiSettingsGetSettingsGet(response: HttpResponseBase): Observable<Settings[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Settings.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiTestEncryptValueGet(connectionString: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Test/EncryptValue?";
        if (connectionString !== undefined && connectionString !== null)
            url_ += "ConnectionString=" + encodeURIComponent("" + connectionString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTestEncryptValueGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTestEncryptValueGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processApiTestEncryptValueGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiTestDecryptValueGet(connectionString: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Test/DecryptValue?";
        if (connectionString !== undefined && connectionString !== null)
            url_ += "ConnectionString=" + encodeURIComponent("" + connectionString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTestDecryptValueGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTestDecryptValueGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processApiTestDecryptValueGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiTestDecryptResponseGet(connectionString: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Test/DecryptResponse?";
        if (connectionString !== undefined && connectionString !== null)
            url_ += "ConnectionString=" + encodeURIComponent("" + connectionString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTestDecryptResponseGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTestDecryptResponseGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processApiTestDecryptResponseGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserEncryptValueGet(connectionString: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/User/EncryptValue?";
        if (connectionString !== undefined && connectionString !== null)
            url_ += "ConnectionString=" + encodeURIComponent("" + connectionString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserEncryptValueGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserEncryptValueGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processApiUserEncryptValueGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserDecryptValueGet(connectionString: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/User/DecryptValue?";
        if (connectionString !== undefined && connectionString !== null)
            url_ += "ConnectionString=" + encodeURIComponent("" + connectionString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserDecryptValueGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserDecryptValueGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processApiUserDecryptValueGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserDecryptResponseGet(connectionString: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/User/DecryptResponse?";
        if (connectionString !== undefined && connectionString !== null)
            url_ += "ConnectionString=" + encodeURIComponent("" + connectionString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserDecryptResponseGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserDecryptResponseGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processApiUserDecryptResponseGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserGetByIdCustomeGet(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/User/GetByIdCustome?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserGetByIdCustomeGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserGetByIdCustomeGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processApiUserGetByIdCustomeGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserGetAllCustomPost(filterData: FilterData): Observable<ViewerPaginationOfMainUserDto> {
        let url_ = this.baseUrl + "/api/User/GetAllCustom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserGetAllCustomPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserGetAllCustomPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfMainUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfMainUserDto>;
        }));
    }

    protected processApiUserGetAllCustomPost(response: HttpResponseBase): Observable<ViewerPaginationOfMainUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfMainUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserGetWithPaginateByRolePost(filterData: FilterData): Observable<ViewerPaginationOfMainUserDto> {
        let url_ = this.baseUrl + "/api/User/getWithPaginateByRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserGetWithPaginateByRolePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserGetWithPaginateByRolePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfMainUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfMainUserDto>;
        }));
    }

    protected processApiUserGetWithPaginateByRolePost(response: HttpResponseBase): Observable<ViewerPaginationOfMainUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfMainUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserLoginPost(model: UserLoginModel): Observable<string> {
        let url_ = this.baseUrl + "/api/User/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserLoginPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserLoginPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processApiUserLoginPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserCheckOTPPost(username: string | null | undefined, otp: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/User/CheckOTP?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (otp !== undefined && otp !== null)
            url_ += "otp=" + encodeURIComponent("" + otp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserCheckOTPPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserCheckOTPPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processApiUserCheckOTPPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserChangePasswordPost(model: ChangePasswordModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserChangePasswordPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserChangePasswordPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiUserChangePasswordPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserRefreshTokenPost(jsonBody: any): Observable<AccessToken> {
        let url_ = this.baseUrl + "/api/User/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(jsonBody);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserRefreshTokenPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserRefreshTokenPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessToken>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessToken>;
        }));
    }

    protected processApiUserRefreshTokenPost(response: HttpResponseBase): Observable<AccessToken> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessToken.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserLogoutGet(refreshToken: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/Logout?";
        if (refreshToken !== undefined && refreshToken !== null)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserLogoutGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserLogoutGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiUserLogoutGet(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserAddUpdateUserPost(iD: number | undefined, passwordHash: string | null | undefined, userName: string | null | undefined, mobile: string | null | undefined, name: string | null | undefined, identity: string | null | undefined, email: string | null | undefined, activeDirectoryUser: boolean | undefined, branch_ID: number | null | undefined, branch_Title: string | null | undefined, branchId: number | null | undefined, userType: UserType | null | undefined, role_ID: number | undefined, role_Name: string | null | undefined, role_NameAr: string | null | undefined, roleId: number | null | undefined, signature: FileParameter | null | undefined, committeeId: number | null | undefined, attachmentBase64: string | null | undefined): Observable<AddUserResponse> {
        let url_ = this.baseUrl + "/api/User/AddUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (iD === null || iD === undefined)
            throw new Error("The parameter 'iD' cannot be null.");
        else
            content_.append("ID", iD.toString());
        if (passwordHash !== null && passwordHash !== undefined)
            content_.append("PasswordHash", passwordHash.toString());
        if (userName !== null && userName !== undefined)
            content_.append("UserName", userName.toString());
        if (mobile !== null && mobile !== undefined)
            content_.append("Mobile", mobile.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (identity !== null && identity !== undefined)
            content_.append("Identity", identity.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (activeDirectoryUser === null || activeDirectoryUser === undefined)
            throw new Error("The parameter 'activeDirectoryUser' cannot be null.");
        else
            content_.append("ActiveDirectoryUser", activeDirectoryUser.toString());
        if (branch_ID !== null && branch_ID !== undefined)
            content_.append("Branch.ID", branch_ID.toString());
        if (branch_Title !== null && branch_Title !== undefined)
            content_.append("Branch.Title", branch_Title.toString());
        if (branchId !== null && branchId !== undefined)
            content_.append("BranchId", branchId.toString());
        if (userType !== null && userType !== undefined)
            content_.append("UserType", userType.toString());
        if (role_ID === null || role_ID === undefined)
            throw new Error("The parameter 'role_ID' cannot be null.");
        else
            content_.append("Role.ID", role_ID.toString());
        if (role_Name !== null && role_Name !== undefined)
            content_.append("Role.Name", role_Name.toString());
        if (role_NameAr !== null && role_NameAr !== undefined)
            content_.append("Role.NameAr", role_NameAr.toString());
        if (roleId !== null && roleId !== undefined)
            content_.append("RoleId", roleId.toString());
        if (signature !== null && signature !== undefined)
            content_.append("Signature", signature.data, signature.fileName ? signature.fileName : "Signature");
        if (committeeId !== null && committeeId !== undefined)
            content_.append("CommitteeId", committeeId.toString());
        if (attachmentBase64 !== null && attachmentBase64 !== undefined)
            content_.append("AttachmentBase64", attachmentBase64.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserAddUpdateUserPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserAddUpdateUserPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddUserResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddUserResponse>;
        }));
    }

    protected processApiUserAddUpdateUserPost(response: HttpResponseBase): Observable<AddUserResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddUserResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserSaveNegotiateUserPost(model: CommitteeRoleViewModel[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/SaveNegotiateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserSaveNegotiateUserPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserSaveNegotiateUserPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiUserSaveNegotiateUserPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserGetAllADUserGet(): Observable<string> {
        let url_ = this.baseUrl + "/api/User/getAllADUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserGetAllADUserGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserGetAllADUserGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processApiUserGetAllADUserGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserGetNegotiatedUserGet(): Observable<CommitteeRoleViewModel[]> {
        let url_ = this.baseUrl + "/api/User/getNegotiatedUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserGetNegotiatedUserGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserGetNegotiatedUserGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommitteeRoleViewModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommitteeRoleViewModel[]>;
        }));
    }

    protected processApiUserGetNegotiatedUserGet(response: HttpResponseBase): Observable<CommitteeRoleViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommitteeRoleViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserUpdateDeptMPost(userId: number | undefined, deptId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/UpdateDeptM?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (deptId === null)
            throw new Error("The parameter 'deptId' cannot be null.");
        else if (deptId !== undefined)
            url_ += "DeptId=" + encodeURIComponent("" + deptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserUpdateDeptMPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserUpdateDeptMPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiUserUpdateDeptMPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserUpdateBrMPost(userId: number | undefined, branchId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/UpdateBrM?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserUpdateBrMPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserUpdateBrMPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiUserUpdateBrMPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserInsertUserSignaturePost(): Observable<void> {
        let url_ = this.baseUrl + "/api/User/InsertUserSignature";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserInsertUserSignaturePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserInsertUserSignaturePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApiUserInsertUserSignaturePost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiUserActivateUserPost(userId: number | undefined, state: boolean | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/ActivateUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserActivateUserPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserActivateUserPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiUserActivateUserPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiWitnessGetByIdGet(id: number | undefined): Observable<Witness> {
        let url_ = this.baseUrl + "/api/Witness/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiWitnessGetByIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiWitnessGetByIdGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Witness>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Witness>;
        }));
    }

    protected processApiWitnessGetByIdGet(response: HttpResponseBase): Observable<Witness> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Witness.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiWitnessGetAllGet(): Observable<WitnessDto[]> {
        let url_ = this.baseUrl + "/api/Witness/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiWitnessGetAllGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiWitnessGetAllGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WitnessDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WitnessDto[]>;
        }));
    }

    protected processApiWitnessGetAllGet(response: HttpResponseBase): Observable<WitnessDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WitnessDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiWitnessGetAllCustomGet(searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<ViewerPaginationOfWitness> {
        let url_ = this.baseUrl + "/api/Witness/GetAllCustom?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiWitnessGetAllCustomGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiWitnessGetAllCustomGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViewerPaginationOfWitness>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViewerPaginationOfWitness>;
        }));
    }

    protected processApiWitnessGetAllCustomGet(response: HttpResponseBase): Observable<ViewerPaginationOfWitness> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewerPaginationOfWitness.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiWitnessInsertPost(model: Witness): Observable<GenericResultOfWitnessDto> {
        let url_ = this.baseUrl + "/api/Witness/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiWitnessInsertPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiWitnessInsertPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResultOfWitnessDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResultOfWitnessDto>;
        }));
    }

    protected processApiWitnessInsertPost(response: HttpResponseBase): Observable<GenericResultOfWitnessDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResultOfWitnessDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    apiWitnessDeletePost(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Witness/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiWitnessDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiWitnessDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiWitnessDeletePost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class CommitteeList implements ICommitteeList {
    id!: number;
    title?: string | undefined;
    code?: string | undefined;
    branchId?: number | undefined;
    branchTitle?: string | undefined;
    contactNumber?: string | undefined;
    departmentDto?: DepartmentDto | undefined;
    committeeDataEntryUsers?: CommitteeRoleViewModel[] | undefined;
    committeeManager?: CommitteeRoleViewModel | undefined;

    constructor(data?: ICommitteeList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.code = _data["code"];
            this.branchId = _data["branchId"];
            this.branchTitle = _data["branchTitle"];
            this.contactNumber = _data["contactNumber"];
            this.departmentDto = _data["departmentDto"] ? DepartmentDto.fromJS(_data["departmentDto"]) : <any>undefined;
            if (Array.isArray(_data["committeeDataEntryUsers"])) {
                this.committeeDataEntryUsers = [] as any;
                for (let item of _data["committeeDataEntryUsers"])
                    this.committeeDataEntryUsers!.push(CommitteeRoleViewModel.fromJS(item));
            }
            this.committeeManager = _data["committeeManager"] ? CommitteeRoleViewModel.fromJS(_data["committeeManager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommitteeList {
        data = typeof data === 'object' ? data : {};
        let result = new CommitteeList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["code"] = this.code;
        data["branchId"] = this.branchId;
        data["branchTitle"] = this.branchTitle;
        data["contactNumber"] = this.contactNumber;
        data["departmentDto"] = this.departmentDto ? this.departmentDto.toJSON() : <any>undefined;
        if (Array.isArray(this.committeeDataEntryUsers)) {
            data["committeeDataEntryUsers"] = [];
            for (let item of this.committeeDataEntryUsers)
                data["committeeDataEntryUsers"].push(item.toJSON());
        }
        data["committeeManager"] = this.committeeManager ? this.committeeManager.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommitteeList {
    id: number;
    title?: string | undefined;
    code?: string | undefined;
    branchId?: number | undefined;
    branchTitle?: string | undefined;
    contactNumber?: string | undefined;
    departmentDto?: DepartmentDto | undefined;
    committeeDataEntryUsers?: CommitteeRoleViewModel[] | undefined;
    committeeManager?: CommitteeRoleViewModel | undefined;
}

export class DepartmentDto implements IDepartmentDto {
    id!: number;
    title?: string | undefined;
    manager?: NameIdViewModel | undefined;

    constructor(data?: IDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.manager = _data["manager"] ? NameIdViewModel.fromJS(_data["manager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["manager"] = this.manager ? this.manager.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDepartmentDto {
    id: number;
    title?: string | undefined;
    manager?: NameIdViewModel | undefined;
}

export class NameIdViewModel implements INameIdViewModel {
    id?: number | undefined;
    title?: string | undefined;

    constructor(data?: INameIdViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): NameIdViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new NameIdViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface INameIdViewModel {
    id?: number | undefined;
    title?: string | undefined;
}

export class CommitteeRoleViewModel implements ICommitteeRoleViewModel {
    id?: number | undefined;
    title?: string | undefined;

    constructor(data?: ICommitteeRoleViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CommitteeRoleViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommitteeRoleViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface ICommitteeRoleViewModel {
    id?: number | undefined;
    title?: string | undefined;
}

export class MainUserNameIDList implements IMainUserNameIDList {
    id!: number;
    name?: string | undefined;

    constructor(data?: IMainUserNameIDList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MainUserNameIDList {
        data = typeof data === 'object' ? data : {};
        let result = new MainUserNameIDList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IMainUserNameIDList {
    id: number;
    name?: string | undefined;
}

export class CommitteeIdName implements ICommitteeIdName {
    id!: number;
    title?: string | undefined;

    constructor(data?: ICommitteeIdName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CommitteeIdName {
        data = typeof data === 'object' ? data : {};
        let result = new CommitteeIdName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface ICommitteeIdName {
    id: number;
    title?: string | undefined;
}

export class ViewerPaginationOfCommitteeList implements IViewerPaginationOfCommitteeList {
    paginationList?: CommitteeList[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfCommitteeList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(CommitteeList.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfCommitteeList {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfCommitteeList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfCommitteeList {
    paginationList?: CommitteeList[] | undefined;
    originalListListCount: number;
}

export class ViewerPaginationOfOrderListDto implements IViewerPaginationOfOrderListDto {
    paginationList?: OrderListDto[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfOrderListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(OrderListDto.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfOrderListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfOrderListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfOrderListDto {
    paginationList?: OrderListDto[] | undefined;
    originalListListCount: number;
}

export class OrderListDto implements IOrderListDto {
    orderCode?: string | undefined;
    muslimeName?: string | undefined;
    muslimeId!: number;
    creationDate!: Date;
    isChecked!: boolean;
    stage?: string | undefined;
    orderTimeLine?: OrderHistoryDto[] | undefined;

    constructor(data?: IOrderListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderCode = _data["orderCode"];
            this.muslimeName = _data["muslimeName"];
            this.muslimeId = _data["muslimeId"];
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            this.isChecked = _data["isChecked"];
            this.stage = _data["stage"];
            if (Array.isArray(_data["orderTimeLine"])) {
                this.orderTimeLine = [] as any;
                for (let item of _data["orderTimeLine"])
                    this.orderTimeLine!.push(OrderHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCode"] = this.orderCode;
        data["muslimeName"] = this.muslimeName;
        data["muslimeId"] = this.muslimeId;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["isChecked"] = this.isChecked;
        data["stage"] = this.stage;
        if (Array.isArray(this.orderTimeLine)) {
            data["orderTimeLine"] = [];
            for (let item of this.orderTimeLine)
                data["orderTimeLine"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderListDto {
    orderCode?: string | undefined;
    muslimeName?: string | undefined;
    muslimeId: number;
    creationDate: Date;
    isChecked: boolean;
    stage?: string | undefined;
    orderTimeLine?: OrderHistoryDto[] | undefined;
}

export class OrderHistoryDto implements IOrderHistoryDto {
    actionDate?: string | undefined;
    description?: string | undefined;
    orderStatus!: OrderStatus;
    dataEntryName?: string | undefined;

    constructor(data?: IOrderHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionDate = _data["actionDate"];
            this.description = _data["description"];
            this.orderStatus = _data["orderStatus"];
            this.dataEntryName = _data["dataEntryName"];
        }
    }

    static fromJS(data: any): OrderHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionDate"] = this.actionDate;
        data["description"] = this.description;
        data["orderStatus"] = this.orderStatus;
        data["dataEntryName"] = this.dataEntryName;
        return data;
    }
}

export interface IOrderHistoryDto {
    actionDate?: string | undefined;
    description?: string | undefined;
    orderStatus: OrderStatus;
    dataEntryName?: string | undefined;
}

export enum OrderStatus {
    Create = 0,
    Send = 1,
    Accept = 2,
    Reject = 3,
    Finished = 4,
    Printed = 5,
}

export class GenericResultOfCommittee implements IGenericResultOfCommittee {
    data?: Committee | undefined;
    message?: string | undefined;
    status!: number;

    constructor(data?: IGenericResultOfCommittee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? Committee.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GenericResultOfCommittee {
        data = typeof data === 'object' ? data : {};
        let result = new GenericResultOfCommittee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["status"] = this.status;
        return data;
    }
}

export interface IGenericResultOfCommittee {
    data?: Committee | undefined;
    message?: string | undefined;
    status: number;
}

export class _Model implements I_Model {
    id!: number;
    createdBy?: number | undefined;
    createdOn?: Date | undefined;
    updatedBy?: number | undefined;
    updatedOn?: Date | undefined;
    deletedBy?: number | undefined;
    deletedOn?: Date | undefined;

    constructor(data?: I_Model) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            this.deletedBy = _data["deletedBy"];
            this.deletedOn = _data["deletedOn"] ? new Date(_data["deletedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): _Model {
        data = typeof data === 'object' ? data : {};
        let result = new _Model();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["deletedBy"] = this.deletedBy;
        data["deletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface I_Model {
    id: number;
    createdBy?: number | undefined;
    createdOn?: Date | undefined;
    updatedBy?: number | undefined;
    updatedOn?: Date | undefined;
    deletedBy?: number | undefined;
    deletedOn?: Date | undefined;
}

export class Committee extends _Model implements ICommittee {
    title?: string | undefined;
    code?: string | undefined;
    contactNumber?: string | undefined;
    departmentId!: number;
    department?: Department | undefined;
    orders?: Order[] | undefined;
    users?: MainUserRole[] | undefined;
    committeeManager?: CommitteeRoleViewModel | undefined;
    committeeDataEntryUsers?: CommitteeRoleViewModel[] | undefined;

    constructor(data?: ICommittee) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.code = _data["code"];
            this.contactNumber = _data["contactNumber"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(Order.fromJS(item));
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(MainUserRole.fromJS(item));
            }
            this.committeeManager = _data["committeeManager"] ? CommitteeRoleViewModel.fromJS(_data["committeeManager"]) : <any>undefined;
            if (Array.isArray(_data["committeeDataEntryUsers"])) {
                this.committeeDataEntryUsers = [] as any;
                for (let item of _data["committeeDataEntryUsers"])
                    this.committeeDataEntryUsers!.push(CommitteeRoleViewModel.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Committee {
        data = typeof data === 'object' ? data : {};
        let result = new Committee();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["code"] = this.code;
        data["contactNumber"] = this.contactNumber;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["committeeManager"] = this.committeeManager ? this.committeeManager.toJSON() : <any>undefined;
        if (Array.isArray(this.committeeDataEntryUsers)) {
            data["committeeDataEntryUsers"] = [];
            for (let item of this.committeeDataEntryUsers)
                data["committeeDataEntryUsers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICommittee extends I_Model {
    title?: string | undefined;
    code?: string | undefined;
    contactNumber?: string | undefined;
    departmentId: number;
    department?: Department | undefined;
    orders?: Order[] | undefined;
    users?: MainUserRole[] | undefined;
    committeeManager?: CommitteeRoleViewModel | undefined;
    committeeDataEntryUsers?: CommitteeRoleViewModel[] | undefined;
}

export class Department extends _Model implements IDepartment {
    title?: string | undefined;
    branshID!: number;
    ministryBransh?: MinistryBransh | undefined;
    mangerRole?: MainUserRole | undefined;

    constructor(data?: IDepartment) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.branshID = _data["branshID"];
            this.ministryBransh = _data["ministryBransh"] ? MinistryBransh.fromJS(_data["ministryBransh"]) : <any>undefined;
            this.mangerRole = _data["mangerRole"] ? MainUserRole.fromJS(_data["mangerRole"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["branshID"] = this.branshID;
        data["ministryBransh"] = this.ministryBransh ? this.ministryBransh.toJSON() : <any>undefined;
        data["mangerRole"] = this.mangerRole ? this.mangerRole.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDepartment extends I_Model {
    title?: string | undefined;
    branshID: number;
    ministryBransh?: MinistryBransh | undefined;
    mangerRole?: MainUserRole | undefined;
}

export class MinistryBransh extends _Model implements IMinistryBransh {
    title?: string | undefined;
    code?: string | undefined;
    userRoleID?: number | undefined;
    userRole?: MainUserRole | undefined;
    department?: Department | undefined;
    users?: MainUser[] | undefined;

    constructor(data?: IMinistryBransh) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.code = _data["code"];
            this.userRoleID = _data["userRoleID"];
            this.userRole = _data["userRole"] ? MainUserRole.fromJS(_data["userRole"]) : <any>undefined;
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(MainUser.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): MinistryBransh {
        data = typeof data === 'object' ? data : {};
        let result = new MinistryBransh();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["code"] = this.code;
        data["userRoleID"] = this.userRoleID;
        data["userRole"] = this.userRole ? this.userRole.toJSON() : <any>undefined;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IMinistryBransh extends I_Model {
    title?: string | undefined;
    code?: string | undefined;
    userRoleID?: number | undefined;
    userRole?: MainUserRole | undefined;
    department?: Department | undefined;
    users?: MainUser[] | undefined;
}

export class MainUserRole extends _Model implements IMainUserRole {
    userId?: number | undefined;
    roleId?: number | undefined;
    committeeId?: number | undefined;
    departmentId?: number | undefined;
    branshId?: number | undefined;
    roleTitle?: string | undefined;
    committee?: Committee | undefined;
    department?: Department | undefined;
    bransh?: MinistryBransh | undefined;
    user?: MainUser | undefined;
    role?: MainRole | undefined;

    constructor(data?: IMainUserRole) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.committeeId = _data["committeeId"];
            this.departmentId = _data["departmentId"];
            this.branshId = _data["branshId"];
            this.roleTitle = _data["roleTitle"];
            this.committee = _data["committee"] ? Committee.fromJS(_data["committee"]) : <any>undefined;
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.bransh = _data["bransh"] ? MinistryBransh.fromJS(_data["bransh"]) : <any>undefined;
            this.user = _data["user"] ? MainUser.fromJS(_data["user"]) : <any>undefined;
            this.role = _data["role"] ? MainRole.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): MainUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new MainUserRole();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["committeeId"] = this.committeeId;
        data["departmentId"] = this.departmentId;
        data["branshId"] = this.branshId;
        data["roleTitle"] = this.roleTitle;
        data["committee"] = this.committee ? this.committee.toJSON() : <any>undefined;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["bransh"] = this.bransh ? this.bransh.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IMainUserRole extends I_Model {
    userId?: number | undefined;
    roleId?: number | undefined;
    committeeId?: number | undefined;
    departmentId?: number | undefined;
    branshId?: number | undefined;
    roleTitle?: string | undefined;
    committee?: Committee | undefined;
    department?: Department | undefined;
    bransh?: MinistryBransh | undefined;
    user?: MainUser | undefined;
    role?: MainRole | undefined;
}

export class MainUser extends _Model implements IMainUser {
    userType!: UserType;
    name?: string | undefined;
    identity?: string | undefined;
    passwordHash?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    attachment?: Attachment | undefined;
    orders?: Order[] | undefined;
    userTokens?: UserToken[] | undefined;
    mainUserRole?: MainUserRole[] | undefined;
    tryloginCount!: number;
    activeDirectoryUser!: boolean;
    display!: boolean;
    passwordChanged!: boolean;
    branchId?: number | undefined;
    bransh?: MinistryBransh | undefined;
    otpCreationTime?: Date | undefined;
    otp?: string | undefined;
    active!: boolean;

    constructor(data?: IMainUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userType = _data["userType"];
            this.name = _data["name"];
            this.identity = _data["identity"];
            this.passwordHash = _data["passwordHash"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.attachment = _data["attachment"] ? Attachment.fromJS(_data["attachment"]) : <any>undefined;
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(Order.fromJS(item));
            }
            if (Array.isArray(_data["userTokens"])) {
                this.userTokens = [] as any;
                for (let item of _data["userTokens"])
                    this.userTokens!.push(UserToken.fromJS(item));
            }
            if (Array.isArray(_data["mainUserRole"])) {
                this.mainUserRole = [] as any;
                for (let item of _data["mainUserRole"])
                    this.mainUserRole!.push(MainUserRole.fromJS(item));
            }
            this.tryloginCount = _data["tryloginCount"];
            this.activeDirectoryUser = _data["activeDirectoryUser"];
            this.display = _data["display"];
            this.passwordChanged = _data["passwordChanged"];
            this.branchId = _data["branchId"];
            this.bransh = _data["bransh"] ? MinistryBransh.fromJS(_data["bransh"]) : <any>undefined;
            this.otpCreationTime = _data["otpCreationTime"] ? new Date(_data["otpCreationTime"].toString()) : <any>undefined;
            this.otp = _data["otp"];
            this.active = _data["active"];
        }
    }

    static override fromJS(data: any): MainUser {
        data = typeof data === 'object' ? data : {};
        let result = new MainUser();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userType"] = this.userType;
        data["name"] = this.name;
        data["identity"] = this.identity;
        data["passwordHash"] = this.passwordHash;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        if (Array.isArray(this.userTokens)) {
            data["userTokens"] = [];
            for (let item of this.userTokens)
                data["userTokens"].push(item.toJSON());
        }
        if (Array.isArray(this.mainUserRole)) {
            data["mainUserRole"] = [];
            for (let item of this.mainUserRole)
                data["mainUserRole"].push(item.toJSON());
        }
        data["tryloginCount"] = this.tryloginCount;
        data["activeDirectoryUser"] = this.activeDirectoryUser;
        data["display"] = this.display;
        data["passwordChanged"] = this.passwordChanged;
        data["branchId"] = this.branchId;
        data["bransh"] = this.bransh ? this.bransh.toJSON() : <any>undefined;
        data["otpCreationTime"] = this.otpCreationTime ? this.otpCreationTime.toISOString() : <any>undefined;
        data["otp"] = this.otp;
        data["active"] = this.active;
        super.toJSON(data);
        return data;
    }
}

export interface IMainUser extends I_Model {
    userType: UserType;
    name?: string | undefined;
    identity?: string | undefined;
    passwordHash?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    attachment?: Attachment | undefined;
    orders?: Order[] | undefined;
    userTokens?: UserToken[] | undefined;
    mainUserRole?: MainUserRole[] | undefined;
    tryloginCount: number;
    activeDirectoryUser: boolean;
    display: boolean;
    passwordChanged: boolean;
    branchId?: number | undefined;
    bransh?: MinistryBransh | undefined;
    otpCreationTime?: Date | undefined;
    otp?: string | undefined;
    active: boolean;
}

export enum UserType {
    DataEntry = 1,
    CommitteeManager = 2,
    DepartmentManager = 3,
    BranchManager = 4,
    SuperAdmin = 5,
    NegoiatedDepartmentManager = 6,
    NegoiatedBranchManager = 7,
    BranchDataEntry = 8,
    None = 9,
}

export class Attachment extends _Model implements IAttachment {
    imageType!: ImageType;
    attachmentFile?: any | undefined;
    attachmentValue?: string | undefined;
    attachmentBase64?: string | undefined;

    constructor(data?: IAttachment) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.imageType = _data["imageType"];
            this.attachmentFile = _data["attachmentFile"];
            this.attachmentValue = _data["attachmentValue"];
            this.attachmentBase64 = _data["attachmentBase64"];
        }
    }

    static override fromJS(data: any): Attachment {
        data = typeof data === 'object' ? data : {};
        let result = new Attachment();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageType"] = this.imageType;
        data["attachmentFile"] = this.attachmentFile;
        data["attachmentValue"] = this.attachmentValue;
        data["attachmentBase64"] = this.attachmentBase64;
        super.toJSON(data);
        return data;
    }
}

export interface IAttachment extends I_Model {
    imageType: ImageType;
    attachmentFile?: any | undefined;
    attachmentValue?: string | undefined;
    attachmentBase64?: string | undefined;
}

export enum ImageType {
    Personal = 0,
    Passport = 1,
    Accommodation = 2,
    Signature = 3,
}

export class Order extends _Model implements IOrder {
    code?: string | undefined;
    orderHistories?: OrderHistory[] | undefined;
    dataEntry?: MainUser | undefined;
    committee?: Committee | undefined;
    muslime?: Muslime | undefined;
    stage!: OrderStage;
    creationDate!: Date;

    constructor(data?: IOrder) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
            if (Array.isArray(_data["orderHistories"])) {
                this.orderHistories = [] as any;
                for (let item of _data["orderHistories"])
                    this.orderHistories!.push(OrderHistory.fromJS(item));
            }
            this.dataEntry = _data["dataEntry"] ? MainUser.fromJS(_data["dataEntry"]) : <any>undefined;
            this.committee = _data["committee"] ? Committee.fromJS(_data["committee"]) : <any>undefined;
            this.muslime = _data["muslime"] ? Muslime.fromJS(_data["muslime"]) : <any>undefined;
            this.stage = _data["stage"];
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        if (Array.isArray(this.orderHistories)) {
            data["orderHistories"] = [];
            for (let item of this.orderHistories)
                data["orderHistories"].push(item.toJSON());
        }
        data["dataEntry"] = this.dataEntry ? this.dataEntry.toJSON() : <any>undefined;
        data["committee"] = this.committee ? this.committee.toJSON() : <any>undefined;
        data["muslime"] = this.muslime ? this.muslime.toJSON() : <any>undefined;
        data["stage"] = this.stage;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IOrder extends I_Model {
    code?: string | undefined;
    orderHistories?: OrderHistory[] | undefined;
    dataEntry?: MainUser | undefined;
    committee?: Committee | undefined;
    muslime?: Muslime | undefined;
    stage: OrderStage;
    creationDate: Date;
}

export class OrderHistory extends _Model implements IOrderHistory {
    actionDate!: Date;
    description?: string | undefined;
    orderStatus!: OrderStatus;
    order?: Order | undefined;
    userId?: number | undefined;
    userName?: string | undefined;

    constructor(data?: IOrderHistory) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.actionDate = _data["actionDate"] ? new Date(_data["actionDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.orderStatus = _data["orderStatus"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static override fromJS(data: any): OrderHistory {
        data = typeof data === 'object' ? data : {};
        let result = new OrderHistory();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["orderStatus"] = this.orderStatus;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        super.toJSON(data);
        return data;
    }
}

export interface IOrderHistory extends I_Model {
    actionDate: Date;
    description?: string | undefined;
    orderStatus: OrderStatus;
    order?: Order | undefined;
    userId?: number | undefined;
    userName?: string | undefined;
}

export class Muslime extends _Model implements IMuslime {
    personalData?: PersonalData | undefined;
    personalInformation?: PersonalInformation | undefined;
    originalCountry?: OriginalCountry | undefined;
    currentResidence?: CurrentResidence | undefined;
    contactData?: ContactData | undefined;
    familyInformation?: FamilyInformation | undefined;
    work?: Work | undefined;
    isslamRecognition?: IsslamRecognition[] | undefined;
    attachment?: Attachment[] | undefined;

    constructor(data?: IMuslime) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.personalData = _data["personalData"] ? PersonalData.fromJS(_data["personalData"]) : <any>undefined;
            this.personalInformation = _data["personalInformation"] ? PersonalInformation.fromJS(_data["personalInformation"]) : <any>undefined;
            this.originalCountry = _data["originalCountry"] ? OriginalCountry.fromJS(_data["originalCountry"]) : <any>undefined;
            this.currentResidence = _data["currentResidence"] ? CurrentResidence.fromJS(_data["currentResidence"]) : <any>undefined;
            this.contactData = _data["contactData"] ? ContactData.fromJS(_data["contactData"]) : <any>undefined;
            this.familyInformation = _data["familyInformation"] ? FamilyInformation.fromJS(_data["familyInformation"]) : <any>undefined;
            this.work = _data["work"] ? Work.fromJS(_data["work"]) : <any>undefined;
            if (Array.isArray(_data["isslamRecognition"])) {
                this.isslamRecognition = [] as any;
                for (let item of _data["isslamRecognition"])
                    this.isslamRecognition!.push(IsslamRecognition.fromJS(item));
            }
            if (Array.isArray(_data["attachment"])) {
                this.attachment = [] as any;
                for (let item of _data["attachment"])
                    this.attachment!.push(Attachment.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Muslime {
        data = typeof data === 'object' ? data : {};
        let result = new Muslime();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personalData"] = this.personalData ? this.personalData.toJSON() : <any>undefined;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["originalCountry"] = this.originalCountry ? this.originalCountry.toJSON() : <any>undefined;
        data["currentResidence"] = this.currentResidence ? this.currentResidence.toJSON() : <any>undefined;
        data["contactData"] = this.contactData ? this.contactData.toJSON() : <any>undefined;
        data["familyInformation"] = this.familyInformation ? this.familyInformation.toJSON() : <any>undefined;
        data["work"] = this.work ? this.work.toJSON() : <any>undefined;
        if (Array.isArray(this.isslamRecognition)) {
            data["isslamRecognition"] = [];
            for (let item of this.isslamRecognition)
                data["isslamRecognition"].push(item.toJSON());
        }
        if (Array.isArray(this.attachment)) {
            data["attachment"] = [];
            for (let item of this.attachment)
                data["attachment"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IMuslime extends I_Model {
    personalData?: PersonalData | undefined;
    personalInformation?: PersonalInformation | undefined;
    originalCountry?: OriginalCountry | undefined;
    currentResidence?: CurrentResidence | undefined;
    contactData?: ContactData | undefined;
    familyInformation?: FamilyInformation | undefined;
    work?: Work | undefined;
    isslamRecognition?: IsslamRecognition[] | undefined;
    attachment?: Attachment[] | undefined;
}

export class PersonalData extends _Model implements IPersonalData {
    nameBeforeFristAr?: string | undefined;
    nameBeforeMiddleAr?: string | undefined;
    nameBeforeLastAr?: string | undefined;
    nameAfter?: string | undefined;
    nameBeforeFristEn?: string | undefined;
    nameBeforeMiddleEn?: string | undefined;
    nameBeforeLastEn?: string | undefined;
    islamDate!: Date;
    nameAfterEn?: string | undefined;
    preacherName?: Preacher | undefined;
    witness?: Witness[] | undefined;

    constructor(data?: IPersonalData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nameBeforeFristAr = _data["nameBeforeFristAr"];
            this.nameBeforeMiddleAr = _data["nameBeforeMiddleAr"];
            this.nameBeforeLastAr = _data["nameBeforeLastAr"];
            this.nameAfter = _data["nameAfter"];
            this.nameBeforeFristEn = _data["nameBeforeFristEn"];
            this.nameBeforeMiddleEn = _data["nameBeforeMiddleEn"];
            this.nameBeforeLastEn = _data["nameBeforeLastEn"];
            this.islamDate = _data["islamDate"] ? new Date(_data["islamDate"].toString()) : <any>undefined;
            this.nameAfterEn = _data["nameAfterEn"];
            this.preacherName = _data["preacherName"] ? Preacher.fromJS(_data["preacherName"]) : <any>undefined;
            if (Array.isArray(_data["witness"])) {
                this.witness = [] as any;
                for (let item of _data["witness"])
                    this.witness!.push(Witness.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PersonalData {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalData();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameBeforeFristAr"] = this.nameBeforeFristAr;
        data["nameBeforeMiddleAr"] = this.nameBeforeMiddleAr;
        data["nameBeforeLastAr"] = this.nameBeforeLastAr;
        data["nameAfter"] = this.nameAfter;
        data["nameBeforeFristEn"] = this.nameBeforeFristEn;
        data["nameBeforeMiddleEn"] = this.nameBeforeMiddleEn;
        data["nameBeforeLastEn"] = this.nameBeforeLastEn;
        data["islamDate"] = this.islamDate ? this.islamDate.toISOString() : <any>undefined;
        data["nameAfterEn"] = this.nameAfterEn;
        data["preacherName"] = this.preacherName ? this.preacherName.toJSON() : <any>undefined;
        if (Array.isArray(this.witness)) {
            data["witness"] = [];
            for (let item of this.witness)
                data["witness"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPersonalData extends I_Model {
    nameBeforeFristAr?: string | undefined;
    nameBeforeMiddleAr?: string | undefined;
    nameBeforeLastAr?: string | undefined;
    nameAfter?: string | undefined;
    nameBeforeFristEn?: string | undefined;
    nameBeforeMiddleEn?: string | undefined;
    nameBeforeLastEn?: string | undefined;
    islamDate: Date;
    nameAfterEn?: string | undefined;
    preacherName?: Preacher | undefined;
    witness?: Witness[] | undefined;
}

export class Preacher extends _Model implements IPreacher {
    title?: string | undefined;
    identity?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: IPreacher) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.identity = _data["identity"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static override fromJS(data: any): Preacher {
        data = typeof data === 'object' ? data : {};
        let result = new Preacher();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["identity"] = this.identity;
        data["contactNumber"] = this.contactNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IPreacher extends I_Model {
    title?: string | undefined;
    identity?: string | undefined;
    contactNumber?: string | undefined;
}

export class Witness extends _Model implements IWitness {
    name?: string | undefined;
    identity?: string | undefined;
    mobile?: string | undefined;
    personalDatas?: PersonalData[] | undefined;

    constructor(data?: IWitness) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.identity = _data["identity"];
            this.mobile = _data["mobile"];
            if (Array.isArray(_data["personalDatas"])) {
                this.personalDatas = [] as any;
                for (let item of _data["personalDatas"])
                    this.personalDatas!.push(PersonalData.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Witness {
        data = typeof data === 'object' ? data : {};
        let result = new Witness();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["identity"] = this.identity;
        data["mobile"] = this.mobile;
        if (Array.isArray(this.personalDatas)) {
            data["personalDatas"] = [];
            for (let item of this.personalDatas)
                data["personalDatas"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IWitness extends I_Model {
    name?: string | undefined;
    identity?: string | undefined;
    mobile?: string | undefined;
    personalDatas?: PersonalData[] | undefined;
}

export class PersonalInformation extends _Model implements IPersonalInformation {
    dateOfBirth!: Date;
    dateOfEntryKingdom!: Date;
    placeOfBirth?: string | undefined;
    nationality?: Country | undefined;
    gender!: Gender;
    previousReligion?: Religion | undefined;
    positionInFamily?: number | undefined;
    maritalStatus?: MaritalStatus | undefined;
    husbandName?: string | undefined;
    educationalLevel?: EducationalLevel | undefined;
    residenceNumber?: string | undefined;
    residenceIssueDate!: Date;
    residenceIssuePlace?: ResidenceIssuePlace | undefined;
    passportNumber?: string | undefined;
    dateOfPassportIssue!: Date;
    placeOfPassportIssue?: string | undefined;

    constructor(data?: IPersonalInformation) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.dateOfEntryKingdom = _data["dateOfEntryKingdom"] ? new Date(_data["dateOfEntryKingdom"].toString()) : <any>undefined;
            this.placeOfBirth = _data["placeOfBirth"];
            this.nationality = _data["nationality"] ? Country.fromJS(_data["nationality"]) : <any>undefined;
            this.gender = _data["gender"];
            this.previousReligion = _data["previousReligion"] ? Religion.fromJS(_data["previousReligion"]) : <any>undefined;
            this.positionInFamily = _data["positionInFamily"];
            this.maritalStatus = _data["maritalStatus"];
            this.husbandName = _data["husbandName"];
            this.educationalLevel = _data["educationalLevel"] ? EducationalLevel.fromJS(_data["educationalLevel"]) : <any>undefined;
            this.residenceNumber = _data["residenceNumber"];
            this.residenceIssueDate = _data["residenceIssueDate"] ? new Date(_data["residenceIssueDate"].toString()) : <any>undefined;
            this.residenceIssuePlace = _data["residenceIssuePlace"] ? ResidenceIssuePlace.fromJS(_data["residenceIssuePlace"]) : <any>undefined;
            this.passportNumber = _data["passportNumber"];
            this.dateOfPassportIssue = _data["dateOfPassportIssue"] ? new Date(_data["dateOfPassportIssue"].toString()) : <any>undefined;
            this.placeOfPassportIssue = _data["placeOfPassportIssue"];
        }
    }

    static override fromJS(data: any): PersonalInformation {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInformation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["dateOfEntryKingdom"] = this.dateOfEntryKingdom ? this.dateOfEntryKingdom.toISOString() : <any>undefined;
        data["placeOfBirth"] = this.placeOfBirth;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["gender"] = this.gender;
        data["previousReligion"] = this.previousReligion ? this.previousReligion.toJSON() : <any>undefined;
        data["positionInFamily"] = this.positionInFamily;
        data["maritalStatus"] = this.maritalStatus;
        data["husbandName"] = this.husbandName;
        data["educationalLevel"] = this.educationalLevel ? this.educationalLevel.toJSON() : <any>undefined;
        data["residenceNumber"] = this.residenceNumber;
        data["residenceIssueDate"] = this.residenceIssueDate ? this.residenceIssueDate.toISOString() : <any>undefined;
        data["residenceIssuePlace"] = this.residenceIssuePlace ? this.residenceIssuePlace.toJSON() : <any>undefined;
        data["passportNumber"] = this.passportNumber;
        data["dateOfPassportIssue"] = this.dateOfPassportIssue ? this.dateOfPassportIssue.toISOString() : <any>undefined;
        data["placeOfPassportIssue"] = this.placeOfPassportIssue;
        super.toJSON(data);
        return data;
    }
}

export interface IPersonalInformation extends I_Model {
    dateOfBirth: Date;
    dateOfEntryKingdom: Date;
    placeOfBirth?: string | undefined;
    nationality?: Country | undefined;
    gender: Gender;
    previousReligion?: Religion | undefined;
    positionInFamily?: number | undefined;
    maritalStatus?: MaritalStatus | undefined;
    husbandName?: string | undefined;
    educationalLevel?: EducationalLevel | undefined;
    residenceNumber?: string | undefined;
    residenceIssueDate: Date;
    residenceIssuePlace?: ResidenceIssuePlace | undefined;
    passportNumber?: string | undefined;
    dateOfPassportIssue: Date;
    placeOfPassportIssue?: string | undefined;
}

export class Country extends _Model implements ICountry {
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    code?: string | undefined;

    constructor(data?: ICountry) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.code = _data["code"];
        }
    }

    static override fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["code"] = this.code;
        super.toJSON(data);
        return data;
    }
}

export interface ICountry extends I_Model {
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    code?: string | undefined;
}

export enum Gender {
    Male = 1,
    Female = 2,
}

export class Religion extends _Model implements IReligion {
    title?: string | undefined;

    constructor(data?: IReligion) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
        }
    }

    static override fromJS(data: any): Religion {
        data = typeof data === 'object' ? data : {};
        let result = new Religion();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        super.toJSON(data);
        return data;
    }
}

export interface IReligion extends I_Model {
    title?: string | undefined;
}

export enum MaritalStatus {
    Single = 1,
    Married = 2,
    Divorced = 3,
    Widowed = 4,
}

export class EducationalLevel extends _Model implements IEducationalLevel {
    title?: string | undefined;

    constructor(data?: IEducationalLevel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
        }
    }

    static override fromJS(data: any): EducationalLevel {
        data = typeof data === 'object' ? data : {};
        let result = new EducationalLevel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        super.toJSON(data);
        return data;
    }
}

export interface IEducationalLevel extends I_Model {
    title?: string | undefined;
}

export class ResidenceIssuePlace extends _Model implements IResidenceIssuePlace {
    title?: string | undefined;

    constructor(data?: IResidenceIssuePlace) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
        }
    }

    static override fromJS(data: any): ResidenceIssuePlace {
        data = typeof data === 'object' ? data : {};
        let result = new ResidenceIssuePlace();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        super.toJSON(data);
        return data;
    }
}

export interface IResidenceIssuePlace extends I_Model {
    title?: string | undefined;
}

export class OriginalCountry extends _Model implements IOriginalCountry {
    country?: Country | undefined;
    city?: string | undefined;
    street?: string | undefined;
    region?: string | undefined;
    doorNumber?: string | undefined;

    constructor(data?: IOriginalCountry) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
            this.city = _data["city"];
            this.street = _data["street"];
            this.region = _data["region"];
            this.doorNumber = _data["doorNumber"];
        }
    }

    static override fromJS(data: any): OriginalCountry {
        data = typeof data === 'object' ? data : {};
        let result = new OriginalCountry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["city"] = this.city;
        data["street"] = this.street;
        data["region"] = this.region;
        data["doorNumber"] = this.doorNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IOriginalCountry extends I_Model {
    country?: Country | undefined;
    city?: string | undefined;
    street?: string | undefined;
    region?: string | undefined;
    doorNumber?: string | undefined;
}

export class CurrentResidence extends _Model implements ICurrentResidence {
    city?: string | undefined;
    street?: string | undefined;
    region?: string | undefined;
    doorNumber?: string | undefined;
    emergencyNumber?: string | undefined;

    constructor(data?: ICurrentResidence) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.city = _data["city"];
            this.street = _data["street"];
            this.region = _data["region"];
            this.doorNumber = _data["doorNumber"];
            this.emergencyNumber = _data["emergencyNumber"];
        }
    }

    static override fromJS(data: any): CurrentResidence {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentResidence();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city;
        data["street"] = this.street;
        data["region"] = this.region;
        data["doorNumber"] = this.doorNumber;
        data["emergencyNumber"] = this.emergencyNumber;
        super.toJSON(data);
        return data;
    }
}

export interface ICurrentResidence extends I_Model {
    city?: string | undefined;
    street?: string | undefined;
    region?: string | undefined;
    doorNumber?: string | undefined;
    emergencyNumber?: string | undefined;
}

export class ContactData extends _Model implements IContactData {
    phoneNumber!: string;
    homeNumber?: string | undefined;
    workNumber?: string | undefined;
    email?: string | undefined;

    constructor(data?: IContactData) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
            this.homeNumber = _data["homeNumber"];
            this.workNumber = _data["workNumber"];
            this.email = _data["email"];
        }
    }

    static override fromJS(data: any): ContactData {
        data = typeof data === 'object' ? data : {};
        let result = new ContactData();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["homeNumber"] = this.homeNumber;
        data["workNumber"] = this.workNumber;
        data["email"] = this.email;
        super.toJSON(data);
        return data;
    }
}

export interface IContactData extends I_Model {
    phoneNumber: string;
    homeNumber?: string | undefined;
    workNumber?: string | undefined;
    email?: string | undefined;
}

export class FamilyInformation extends _Model implements IFamilyInformation {
    membersNumber?: number | undefined;
    boysNumber?: number | undefined;
    girlsNumber?: number | undefined;

    constructor(data?: IFamilyInformation) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.membersNumber = _data["membersNumber"];
            this.boysNumber = _data["boysNumber"];
            this.girlsNumber = _data["girlsNumber"];
        }
    }

    static override fromJS(data: any): FamilyInformation {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyInformation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["membersNumber"] = this.membersNumber;
        data["boysNumber"] = this.boysNumber;
        data["girlsNumber"] = this.girlsNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IFamilyInformation extends I_Model {
    membersNumber?: number | undefined;
    boysNumber?: number | undefined;
    girlsNumber?: number | undefined;
}

export class Work extends _Model implements IWork {
    profession!: string;
    companyTitle?: string | undefined;
    directManager?: string | undefined;
    city?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    postalBox?: string | undefined;
    postalCode?: string | undefined;

    constructor(data?: IWork) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.profession = _data["profession"];
            this.companyTitle = _data["companyTitle"];
            this.directManager = _data["directManager"];
            this.city = _data["city"];
            this.street = _data["street"];
            this.address = _data["address"];
            this.postalBox = _data["postalBox"];
            this.postalCode = _data["postalCode"];
        }
    }

    static override fromJS(data: any): Work {
        data = typeof data === 'object' ? data : {};
        let result = new Work();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profession"] = this.profession;
        data["companyTitle"] = this.companyTitle;
        data["directManager"] = this.directManager;
        data["city"] = this.city;
        data["street"] = this.street;
        data["address"] = this.address;
        data["postalBox"] = this.postalBox;
        data["postalCode"] = this.postalCode;
        super.toJSON(data);
        return data;
    }
}

export interface IWork extends I_Model {
    profession: string;
    companyTitle?: string | undefined;
    directManager?: string | undefined;
    city?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    postalBox?: string | undefined;
    postalCode?: string | undefined;
}

export class IsslamRecognition extends _Model implements IIsslamRecognition {
    title?: string | undefined;
    muslimes?: Muslime[] | undefined;

    constructor(data?: IIsslamRecognition) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["muslimes"])) {
                this.muslimes = [] as any;
                for (let item of _data["muslimes"])
                    this.muslimes!.push(Muslime.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): IsslamRecognition {
        data = typeof data === 'object' ? data : {};
        let result = new IsslamRecognition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.muslimes)) {
            data["muslimes"] = [];
            for (let item of this.muslimes)
                data["muslimes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IIsslamRecognition extends I_Model {
    title?: string | undefined;
    muslimes?: Muslime[] | undefined;
}

export enum OrderStage {
    DataEntry = 0,
    Committee = 1,
    Department = 2,
    Branch = 3,
    ReadyToPrintCard = 4,
    Other = 5,
}

export class UserToken extends _Model implements IUserToken {
    accessTokenHash?: string | undefined;
    accessTokenExpiresDateTime!: Date;
    refreshTokenIdHash?: string | undefined;
    refreshTokenIdHashSource?: string | undefined;
    refreshTokenExpiresDateTime!: Date;
    userId!: number;
    applicationType?: number | undefined;
    user?: MainUser | undefined;

    constructor(data?: IUserToken) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accessTokenHash = _data["accessTokenHash"];
            this.accessTokenExpiresDateTime = _data["accessTokenExpiresDateTime"] ? new Date(_data["accessTokenExpiresDateTime"].toString()) : <any>undefined;
            this.refreshTokenIdHash = _data["refreshTokenIdHash"];
            this.refreshTokenIdHashSource = _data["refreshTokenIdHashSource"];
            this.refreshTokenExpiresDateTime = _data["refreshTokenExpiresDateTime"] ? new Date(_data["refreshTokenExpiresDateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.applicationType = _data["applicationType"];
            this.user = _data["user"] ? MainUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessTokenHash"] = this.accessTokenHash;
        data["accessTokenExpiresDateTime"] = this.accessTokenExpiresDateTime ? this.accessTokenExpiresDateTime.toISOString() : <any>undefined;
        data["refreshTokenIdHash"] = this.refreshTokenIdHash;
        data["refreshTokenIdHashSource"] = this.refreshTokenIdHashSource;
        data["refreshTokenExpiresDateTime"] = this.refreshTokenExpiresDateTime ? this.refreshTokenExpiresDateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["applicationType"] = this.applicationType;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IUserToken extends I_Model {
    accessTokenHash?: string | undefined;
    accessTokenExpiresDateTime: Date;
    refreshTokenIdHash?: string | undefined;
    refreshTokenIdHashSource?: string | undefined;
    refreshTokenExpiresDateTime: Date;
    userId: number;
    applicationType?: number | undefined;
    user?: MainUser | undefined;
}

export class MainRole extends _Model implements IMainRole {
    code!: string;
    nameAr?: string | undefined;
    mainUserRole?: MainUserRole[] | undefined;

    constructor(data?: IMainRole) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
            this.nameAr = _data["nameAr"];
            if (Array.isArray(_data["mainUserRole"])) {
                this.mainUserRole = [] as any;
                for (let item of _data["mainUserRole"])
                    this.mainUserRole!.push(MainUserRole.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): MainRole {
        data = typeof data === 'object' ? data : {};
        let result = new MainRole();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["nameAr"] = this.nameAr;
        if (Array.isArray(this.mainUserRole)) {
            data["mainUserRole"] = [];
            for (let item of this.mainUserRole)
                data["mainUserRole"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IMainRole extends I_Model {
    code: string;
    nameAr?: string | undefined;
    mainUserRole?: MainUserRole[] | undefined;
}

export class CommitteeDto implements ICommitteeDto {
    id!: number;
    title?: string | undefined;
    code?: string | undefined;
    branchId?: number | undefined;
    contactNumber?: string | undefined;
    departmentDto?: DepartmentDto | undefined;
    committeeManager?: CommitteeRoleViewModel | undefined;
    committeeDataEntryUsers?: CommitteeRoleViewModel[] | undefined;

    constructor(data?: ICommitteeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.code = _data["code"];
            this.branchId = _data["branchId"];
            this.contactNumber = _data["contactNumber"];
            this.departmentDto = _data["departmentDto"] ? DepartmentDto.fromJS(_data["departmentDto"]) : <any>undefined;
            this.committeeManager = _data["committeeManager"] ? CommitteeRoleViewModel.fromJS(_data["committeeManager"]) : <any>undefined;
            if (Array.isArray(_data["committeeDataEntryUsers"])) {
                this.committeeDataEntryUsers = [] as any;
                for (let item of _data["committeeDataEntryUsers"])
                    this.committeeDataEntryUsers!.push(CommitteeRoleViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommitteeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommitteeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["code"] = this.code;
        data["branchId"] = this.branchId;
        data["contactNumber"] = this.contactNumber;
        data["departmentDto"] = this.departmentDto ? this.departmentDto.toJSON() : <any>undefined;
        data["committeeManager"] = this.committeeManager ? this.committeeManager.toJSON() : <any>undefined;
        if (Array.isArray(this.committeeDataEntryUsers)) {
            data["committeeDataEntryUsers"] = [];
            for (let item of this.committeeDataEntryUsers)
                data["committeeDataEntryUsers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICommitteeDto {
    id: number;
    title?: string | undefined;
    code?: string | undefined;
    branchId?: number | undefined;
    contactNumber?: string | undefined;
    departmentDto?: DepartmentDto | undefined;
    committeeManager?: CommitteeRoleViewModel | undefined;
    committeeDataEntryUsers?: CommitteeRoleViewModel[] | undefined;
}

export class OrderTransfereDTO implements IOrderTransfereDTO {
    id!: number;
    fromUser!: number;
    toUser!: number;

    constructor(data?: IOrderTransfereDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromUser = _data["fromUser"];
            this.toUser = _data["toUser"];
        }
    }

    static fromJS(data: any): OrderTransfereDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OrderTransfereDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromUser"] = this.fromUser;
        data["toUser"] = this.toUser;
        return data;
    }
}

export interface IOrderTransfereDTO {
    id: number;
    fromUser: number;
    toUser: number;
}

export class ViewerPaginationOfIsslamRecognitionDto implements IViewerPaginationOfIsslamRecognitionDto {
    paginationList?: IsslamRecognitionDto[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfIsslamRecognitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(IsslamRecognitionDto.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfIsslamRecognitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfIsslamRecognitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfIsslamRecognitionDto {
    paginationList?: IsslamRecognitionDto[] | undefined;
    originalListListCount: number;
}

export class IsslamRecognitionDto extends _Model implements IIsslamRecognitionDto {
    title?: string | undefined;

    constructor(data?: IIsslamRecognitionDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
        }
    }

    static override fromJS(data: any): IsslamRecognitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new IsslamRecognitionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        super.toJSON(data);
        return data;
    }
}

export interface IIsslamRecognitionDto extends I_Model {
    title?: string | undefined;
}

export class GenericResultOfIsslamRecognition implements IGenericResultOfIsslamRecognition {
    data?: IsslamRecognition | undefined;
    message?: string | undefined;
    status!: number;

    constructor(data?: IGenericResultOfIsslamRecognition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? IsslamRecognition.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GenericResultOfIsslamRecognition {
        data = typeof data === 'object' ? data : {};
        let result = new GenericResultOfIsslamRecognition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["status"] = this.status;
        return data;
    }
}

export interface IGenericResultOfIsslamRecognition {
    data?: IsslamRecognition | undefined;
    message?: string | undefined;
    status: number;
}

export class ViewerPaginationOfLocalizationDetailsDTO implements IViewerPaginationOfLocalizationDetailsDTO {
    paginationList?: LocalizationDetailsDTO[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfLocalizationDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(LocalizationDetailsDTO.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfLocalizationDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfLocalizationDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfLocalizationDetailsDTO {
    paginationList?: LocalizationDetailsDTO[] | undefined;
    originalListListCount: number;
}

export class LocalizationDetailsDTO implements ILocalizationDetailsDTO {
    id!: number;
    key?: string | undefined;
    valueAr?: string | undefined;
    valueEn?: string | undefined;
    valueFn?: string | undefined;

    constructor(data?: ILocalizationDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.valueAr = _data["valueAr"];
            this.valueEn = _data["valueEn"];
            this.valueFn = _data["valueFn"];
        }
    }

    static fromJS(data: any): LocalizationDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["valueAr"] = this.valueAr;
        data["valueEn"] = this.valueEn;
        data["valueFn"] = this.valueFn;
        return data;
    }
}

export interface ILocalizationDetailsDTO {
    id: number;
    key?: string | undefined;
    valueAr?: string | undefined;
    valueEn?: string | undefined;
    valueFn?: string | undefined;
}

export class BranshDto implements IBranshDto {
    id?: number | undefined;
    title?: string | undefined;

    constructor(data?: IBranshDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): BranshDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranshDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface IBranshDto {
    id?: number | undefined;
    title?: string | undefined;
}

export class ViewerPaginationOfDepartmentDto implements IViewerPaginationOfDepartmentDto {
    paginationList?: DepartmentDto[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(DepartmentDto.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfDepartmentDto {
    paginationList?: DepartmentDto[] | undefined;
    originalListListCount: number;
}

export class ViewerPaginationOfBranshListDto implements IViewerPaginationOfBranshListDto {
    paginationList?: BranshListDto[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfBranshListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(BranshListDto.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfBranshListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfBranshListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfBranshListDto {
    paginationList?: BranshListDto[] | undefined;
    originalListListCount: number;
}

export class BranshListDto implements IBranshListDto {
    id!: number;
    title?: string | undefined;
    manager?: NameIdViewModel | undefined;

    constructor(data?: IBranshListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.manager = _data["manager"] ? NameIdViewModel.fromJS(_data["manager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BranshListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranshListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["manager"] = this.manager ? this.manager.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBranshListDto {
    id: number;
    title?: string | undefined;
    manager?: NameIdViewModel | undefined;
}

export class ViewerPaginationOfResidenceIssuePlace implements IViewerPaginationOfResidenceIssuePlace {
    paginationList?: ResidenceIssuePlace[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfResidenceIssuePlace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(ResidenceIssuePlace.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfResidenceIssuePlace {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfResidenceIssuePlace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfResidenceIssuePlace {
    paginationList?: ResidenceIssuePlace[] | undefined;
    originalListListCount: number;
}

export class ViewerPaginationOfPreacher implements IViewerPaginationOfPreacher {
    paginationList?: Preacher[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfPreacher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(Preacher.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfPreacher {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfPreacher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfPreacher {
    paginationList?: Preacher[] | undefined;
    originalListListCount: number;
}

export class IsslamRecognitionData implements IIsslamRecognitionData {
    id!: number;
    title?: string | undefined;

    constructor(data?: IIsslamRecognitionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): IsslamRecognitionData {
        data = typeof data === 'object' ? data : {};
        let result = new IsslamRecognitionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface IIsslamRecognitionData {
    id: number;
    title?: string | undefined;
}

export class MainRoleNameId implements IMainRoleNameId {
    id!: number;
    name?: string | undefined;
    nameAr?: string | undefined;

    constructor(data?: IMainRoleNameId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
        }
    }

    static fromJS(data: any): MainRoleNameId {
        data = typeof data === 'object' ? data : {};
        let result = new MainRoleNameId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        return data;
    }
}

export interface IMainRoleNameId {
    id: number;
    name?: string | undefined;
    nameAr?: string | undefined;
}

export class MuslimeDto extends _Model implements IMuslimeDto {
    personalData?: PersonalDataDto | undefined;
    personalInformation?: PersonalInformationDto | undefined;
    originalCountry?: OriginalCountryDto | undefined;
    currentResidence?: CurrentResidenceDto | undefined;
    contactData?: ContactAndInfoDataViewModel | undefined;
    familyInformation?: FamilyAndWorkDto | undefined;
    isslamRecognition?: IslamRecognitionWayDto | undefined;
    attachment?: AttachmentDto | undefined;
    witness?: WitnessDto[] | undefined;

    constructor(data?: IMuslimeDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.personalData = _data["personalData"] ? PersonalDataDto.fromJS(_data["personalData"]) : <any>undefined;
            this.personalInformation = _data["personalInformation"] ? PersonalInformationDto.fromJS(_data["personalInformation"]) : <any>undefined;
            this.originalCountry = _data["originalCountry"] ? OriginalCountryDto.fromJS(_data["originalCountry"]) : <any>undefined;
            this.currentResidence = _data["currentResidence"] ? CurrentResidenceDto.fromJS(_data["currentResidence"]) : <any>undefined;
            this.contactData = _data["contactData"] ? ContactAndInfoDataViewModel.fromJS(_data["contactData"]) : <any>undefined;
            this.familyInformation = _data["familyInformation"] ? FamilyAndWorkDto.fromJS(_data["familyInformation"]) : <any>undefined;
            this.isslamRecognition = _data["isslamRecognition"] ? IslamRecognitionWayDto.fromJS(_data["isslamRecognition"]) : <any>undefined;
            this.attachment = _data["attachment"] ? AttachmentDto.fromJS(_data["attachment"]) : <any>undefined;
            if (Array.isArray(_data["witness"])) {
                this.witness = [] as any;
                for (let item of _data["witness"])
                    this.witness!.push(WitnessDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): MuslimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MuslimeDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personalData"] = this.personalData ? this.personalData.toJSON() : <any>undefined;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["originalCountry"] = this.originalCountry ? this.originalCountry.toJSON() : <any>undefined;
        data["currentResidence"] = this.currentResidence ? this.currentResidence.toJSON() : <any>undefined;
        data["contactData"] = this.contactData ? this.contactData.toJSON() : <any>undefined;
        data["familyInformation"] = this.familyInformation ? this.familyInformation.toJSON() : <any>undefined;
        data["isslamRecognition"] = this.isslamRecognition ? this.isslamRecognition.toJSON() : <any>undefined;
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        if (Array.isArray(this.witness)) {
            data["witness"] = [];
            for (let item of this.witness)
                data["witness"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IMuslimeDto extends I_Model {
    personalData?: PersonalDataDto | undefined;
    personalInformation?: PersonalInformationDto | undefined;
    originalCountry?: OriginalCountryDto | undefined;
    currentResidence?: CurrentResidenceDto | undefined;
    contactData?: ContactAndInfoDataViewModel | undefined;
    familyInformation?: FamilyAndWorkDto | undefined;
    isslamRecognition?: IslamRecognitionWayDto | undefined;
    attachment?: AttachmentDto | undefined;
    witness?: WitnessDto[] | undefined;
}

export class PersonalDataDto extends _Model implements IPersonalDataDto {
    muslimeId!: number;
    nameBeforeFristAr!: string;
    nameBeforeMiddleAr?: string | undefined;
    nameBeforeLastAr!: string;
    nameAfter!: string;
    nameAfterEn!: string;
    nameBeforeFristEn?: string | undefined;
    nameBeforeMiddleEn?: string | undefined;
    nameBeforeLastEn?: string | undefined;
    islamDate!: Date;
    preacherName?: Preacher | undefined;
    firstWitness!: WitnessDto;
    secondWitness!: WitnessDto;

    constructor(data?: IPersonalDataDto) {
        super(data);
        if (!data) {
            this.firstWitness = new WitnessDto();
            this.secondWitness = new WitnessDto();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.muslimeId = _data["muslimeId"];
            this.nameBeforeFristAr = _data["nameBeforeFristAr"];
            this.nameBeforeMiddleAr = _data["nameBeforeMiddleAr"];
            this.nameBeforeLastAr = _data["nameBeforeLastAr"];
            this.nameAfter = _data["nameAfter"];
            this.nameAfterEn = _data["nameAfterEn"];
            this.nameBeforeFristEn = _data["nameBeforeFristEn"];
            this.nameBeforeMiddleEn = _data["nameBeforeMiddleEn"];
            this.nameBeforeLastEn = _data["nameBeforeLastEn"];
            this.islamDate = _data["islamDate"] ? new Date(_data["islamDate"].toString()) : <any>undefined;
            this.preacherName = _data["preacherName"] ? Preacher.fromJS(_data["preacherName"]) : <any>undefined;
            this.firstWitness = _data["firstWitness"] ? WitnessDto.fromJS(_data["firstWitness"]) : new WitnessDto();
            this.secondWitness = _data["secondWitness"] ? WitnessDto.fromJS(_data["secondWitness"]) : new WitnessDto();
        }
    }

    static override fromJS(data: any): PersonalDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalDataDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muslimeId"] = this.muslimeId;
        data["nameBeforeFristAr"] = this.nameBeforeFristAr;
        data["nameBeforeMiddleAr"] = this.nameBeforeMiddleAr;
        data["nameBeforeLastAr"] = this.nameBeforeLastAr;
        data["nameAfter"] = this.nameAfter;
        data["nameAfterEn"] = this.nameAfterEn;
        data["nameBeforeFristEn"] = this.nameBeforeFristEn;
        data["nameBeforeMiddleEn"] = this.nameBeforeMiddleEn;
        data["nameBeforeLastEn"] = this.nameBeforeLastEn;
        data["islamDate"] = this.islamDate ? this.islamDate.toISOString() : <any>undefined;
        data["preacherName"] = this.preacherName ? this.preacherName.toJSON() : <any>undefined;
        data["firstWitness"] = this.firstWitness ? this.firstWitness.toJSON() : <any>undefined;
        data["secondWitness"] = this.secondWitness ? this.secondWitness.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPersonalDataDto extends I_Model {
    muslimeId: number;
    nameBeforeFristAr: string;
    nameBeforeMiddleAr?: string | undefined;
    nameBeforeLastAr: string;
    nameAfter: string;
    nameAfterEn: string;
    nameBeforeFristEn?: string | undefined;
    nameBeforeMiddleEn?: string | undefined;
    nameBeforeLastEn?: string | undefined;
    islamDate: Date;
    preacherName?: Preacher | undefined;
    firstWitness: WitnessDto;
    secondWitness: WitnessDto;
}

export class WitnessDto implements IWitnessDto {
    id!: number;
    muslimeId!: number;
    name?: string | undefined;

    constructor(data?: IWitnessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.muslimeId = _data["muslimeId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WitnessDto {
        data = typeof data === 'object' ? data : {};
        let result = new WitnessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["muslimeId"] = this.muslimeId;
        data["name"] = this.name;
        return data;
    }
}

export interface IWitnessDto {
    id: number;
    muslimeId: number;
    name?: string | undefined;
}

export class PersonalInformationDto extends _Model implements IPersonalInformationDto {
    muslimeId!: number;
    dateOfBirth!: Date;
    dateOfEntryKingdom!: Date;
    placeOfBirth!: string;
    nationality!: Country;
    gender!: Gender;
    previousReligion!: Religion;
    positionInFamily?: number | undefined;
    maritalStatus?: MaritalStatus | undefined;
    husbandName?: string | undefined;
    educationalLevel!: EducationalLevel;
    residenceNumber?: string | undefined;
    residenceIssueDate!: Date;
    residenceIssuePlace!: ResidenceIssuePlace;
    passportNumber?: string | undefined;
    dateOfPassportIssue!: Date;
    placeOfPassportIssue?: string | undefined;

    constructor(data?: IPersonalInformationDto) {
        super(data);
        if (!data) {
            this.nationality = new Country();
            this.previousReligion = new Religion();
            this.educationalLevel = new EducationalLevel();
            this.residenceIssuePlace = new ResidenceIssuePlace();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.muslimeId = _data["muslimeId"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.dateOfEntryKingdom = _data["dateOfEntryKingdom"] ? new Date(_data["dateOfEntryKingdom"].toString()) : <any>undefined;
            this.placeOfBirth = _data["placeOfBirth"];
            this.nationality = _data["nationality"] ? Country.fromJS(_data["nationality"]) : new Country();
            this.gender = _data["gender"];
            this.previousReligion = _data["previousReligion"] ? Religion.fromJS(_data["previousReligion"]) : new Religion();
            this.positionInFamily = _data["positionInFamily"];
            this.maritalStatus = _data["maritalStatus"];
            this.husbandName = _data["husbandName"];
            this.educationalLevel = _data["educationalLevel"] ? EducationalLevel.fromJS(_data["educationalLevel"]) : new EducationalLevel();
            this.residenceNumber = _data["residenceNumber"];
            this.residenceIssueDate = _data["residenceIssueDate"] ? new Date(_data["residenceIssueDate"].toString()) : <any>undefined;
            this.residenceIssuePlace = _data["residenceIssuePlace"] ? ResidenceIssuePlace.fromJS(_data["residenceIssuePlace"]) : new ResidenceIssuePlace();
            this.passportNumber = _data["passportNumber"];
            this.dateOfPassportIssue = _data["dateOfPassportIssue"] ? new Date(_data["dateOfPassportIssue"].toString()) : <any>undefined;
            this.placeOfPassportIssue = _data["placeOfPassportIssue"];
        }
    }

    static override fromJS(data: any): PersonalInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInformationDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muslimeId"] = this.muslimeId;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["dateOfEntryKingdom"] = this.dateOfEntryKingdom ? this.dateOfEntryKingdom.toISOString() : <any>undefined;
        data["placeOfBirth"] = this.placeOfBirth;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["gender"] = this.gender;
        data["previousReligion"] = this.previousReligion ? this.previousReligion.toJSON() : <any>undefined;
        data["positionInFamily"] = this.positionInFamily;
        data["maritalStatus"] = this.maritalStatus;
        data["husbandName"] = this.husbandName;
        data["educationalLevel"] = this.educationalLevel ? this.educationalLevel.toJSON() : <any>undefined;
        data["residenceNumber"] = this.residenceNumber;
        data["residenceIssueDate"] = this.residenceIssueDate ? this.residenceIssueDate.toISOString() : <any>undefined;
        data["residenceIssuePlace"] = this.residenceIssuePlace ? this.residenceIssuePlace.toJSON() : <any>undefined;
        data["passportNumber"] = this.passportNumber;
        data["dateOfPassportIssue"] = this.dateOfPassportIssue ? this.dateOfPassportIssue.toISOString() : <any>undefined;
        data["placeOfPassportIssue"] = this.placeOfPassportIssue;
        super.toJSON(data);
        return data;
    }
}

export interface IPersonalInformationDto extends I_Model {
    muslimeId: number;
    dateOfBirth: Date;
    dateOfEntryKingdom: Date;
    placeOfBirth: string;
    nationality: Country;
    gender: Gender;
    previousReligion: Religion;
    positionInFamily?: number | undefined;
    maritalStatus?: MaritalStatus | undefined;
    husbandName?: string | undefined;
    educationalLevel: EducationalLevel;
    residenceNumber?: string | undefined;
    residenceIssueDate: Date;
    residenceIssuePlace: ResidenceIssuePlace;
    passportNumber?: string | undefined;
    dateOfPassportIssue: Date;
    placeOfPassportIssue?: string | undefined;
}

export class OriginalCountryDto extends _Model implements IOriginalCountryDto {
    muslimeId!: number;
    countryId!: number;
    city?: string | undefined;
    street?: string | undefined;
    region?: string | undefined;
    doorNumber?: string | undefined;

    constructor(data?: IOriginalCountryDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.muslimeId = _data["muslimeId"];
            this.countryId = _data["countryId"];
            this.city = _data["city"];
            this.street = _data["street"];
            this.region = _data["region"];
            this.doorNumber = _data["doorNumber"];
        }
    }

    static override fromJS(data: any): OriginalCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OriginalCountryDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muslimeId"] = this.muslimeId;
        data["countryId"] = this.countryId;
        data["city"] = this.city;
        data["street"] = this.street;
        data["region"] = this.region;
        data["doorNumber"] = this.doorNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IOriginalCountryDto extends I_Model {
    muslimeId: number;
    countryId: number;
    city?: string | undefined;
    street?: string | undefined;
    region?: string | undefined;
    doorNumber?: string | undefined;
}

export class CurrentResidenceDto extends _Model implements ICurrentResidenceDto {
    muslimeId!: number;
    city!: string;
    street?: string | undefined;
    region?: string | undefined;
    doorNumber?: string | undefined;
    emergencyNumber?: string | undefined;

    constructor(data?: ICurrentResidenceDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.muslimeId = _data["muslimeId"];
            this.city = _data["city"];
            this.street = _data["street"];
            this.region = _data["region"];
            this.doorNumber = _data["doorNumber"];
            this.emergencyNumber = _data["emergencyNumber"];
        }
    }

    static override fromJS(data: any): CurrentResidenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentResidenceDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muslimeId"] = this.muslimeId;
        data["city"] = this.city;
        data["street"] = this.street;
        data["region"] = this.region;
        data["doorNumber"] = this.doorNumber;
        data["emergencyNumber"] = this.emergencyNumber;
        super.toJSON(data);
        return data;
    }
}

export interface ICurrentResidenceDto extends I_Model {
    muslimeId: number;
    city: string;
    street?: string | undefined;
    region?: string | undefined;
    doorNumber?: string | undefined;
    emergencyNumber?: string | undefined;
}

export class ContactAndInfoDataViewModel implements IContactAndInfoDataViewModel {
    muslimeId!: number;
    originalCountry?: OriginalCountry | undefined;
    currentResidence?: CurrentResidence | undefined;
    contactData?: ContactData | undefined;

    constructor(data?: IContactAndInfoDataViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muslimeId = _data["muslimeId"];
            this.originalCountry = _data["originalCountry"] ? OriginalCountry.fromJS(_data["originalCountry"]) : <any>undefined;
            this.currentResidence = _data["currentResidence"] ? CurrentResidence.fromJS(_data["currentResidence"]) : <any>undefined;
            this.contactData = _data["contactData"] ? ContactData.fromJS(_data["contactData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactAndInfoDataViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAndInfoDataViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muslimeId"] = this.muslimeId;
        data["originalCountry"] = this.originalCountry ? this.originalCountry.toJSON() : <any>undefined;
        data["currentResidence"] = this.currentResidence ? this.currentResidence.toJSON() : <any>undefined;
        data["contactData"] = this.contactData ? this.contactData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContactAndInfoDataViewModel {
    muslimeId: number;
    originalCountry?: OriginalCountry | undefined;
    currentResidence?: CurrentResidence | undefined;
    contactData?: ContactData | undefined;
}

export class FamilyAndWorkDto implements IFamilyAndWorkDto {
    muslimeId!: number;
    familyInformation?: FamilyInformation | undefined;
    work?: Work | undefined;

    constructor(data?: IFamilyAndWorkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muslimeId = _data["muslimeId"];
            this.familyInformation = _data["familyInformation"] ? FamilyInformation.fromJS(_data["familyInformation"]) : <any>undefined;
            this.work = _data["work"] ? Work.fromJS(_data["work"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FamilyAndWorkDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyAndWorkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muslimeId"] = this.muslimeId;
        data["familyInformation"] = this.familyInformation ? this.familyInformation.toJSON() : <any>undefined;
        data["work"] = this.work ? this.work.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFamilyAndWorkDto {
    muslimeId: number;
    familyInformation?: FamilyInformation | undefined;
    work?: Work | undefined;
}

export class IslamRecognitionWayDto implements IIslamRecognitionWayDto {
    muslimeId!: number;
    islamRecognitionWay?: IsslamRecognitionData[] | undefined;

    constructor(data?: IIslamRecognitionWayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muslimeId = _data["muslimeId"];
            if (Array.isArray(_data["islamRecognitionWay"])) {
                this.islamRecognitionWay = [] as any;
                for (let item of _data["islamRecognitionWay"])
                    this.islamRecognitionWay!.push(IsslamRecognitionData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IslamRecognitionWayDto {
        data = typeof data === 'object' ? data : {};
        let result = new IslamRecognitionWayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muslimeId"] = this.muslimeId;
        if (Array.isArray(this.islamRecognitionWay)) {
            data["islamRecognitionWay"] = [];
            for (let item of this.islamRecognitionWay)
                data["islamRecognitionWay"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIslamRecognitionWayDto {
    muslimeId: number;
    islamRecognitionWay?: IsslamRecognitionData[] | undefined;
}

export class AttachmentDto extends _Model implements IAttachmentDto {
    muslimeId!: number;
    personal?: any | undefined;
    accomodation?: any | undefined;
    passport?: any | undefined;
    _Personal?: string | undefined;
    _Accomodation?: string | undefined;
    _Passport?: string | undefined;

    constructor(data?: IAttachmentDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.muslimeId = _data["muslimeId"];
            this.personal = _data["personal"];
            this.accomodation = _data["accomodation"];
            this.passport = _data["passport"];
            this._Personal = _data["_Personal"];
            this._Accomodation = _data["_Accomodation"];
            this._Passport = _data["_Passport"];
        }
    }

    static override fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muslimeId"] = this.muslimeId;
        data["personal"] = this.personal;
        data["accomodation"] = this.accomodation;
        data["passport"] = this.passport;
        data["_Personal"] = this._Personal;
        data["_Accomodation"] = this._Accomodation;
        data["_Passport"] = this._Passport;
        super.toJSON(data);
        return data;
    }
}

export interface IAttachmentDto extends I_Model {
    muslimeId: number;
    personal?: any | undefined;
    accomodation?: any | undefined;
    passport?: any | undefined;
    _Personal?: string | undefined;
    _Accomodation?: string | undefined;
    _Passport?: string | undefined;
}

export class UserDataForVieweing implements IUserDataForVieweing {
    id!: number;
    nameBeforeAr?: string | undefined;
    nameAfter?: string | undefined;
    nameAfterEn?: string | undefined;
    islamDate!: Date;
    dateOfEntryKingdom!: Date;
    placeOfBirth?: string | undefined;
    nationality?: string | undefined;
    previousReligion?: string | undefined;
    residenceNumber?: string | undefined;
    passportNumber?: string | undefined;
    city?: string | undefined;
    street?: string | undefined;
    region?: string | undefined;

    constructor(data?: IUserDataForVieweing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameBeforeAr = _data["nameBeforeAr"];
            this.nameAfter = _data["nameAfter"];
            this.nameAfterEn = _data["nameAfterEn"];
            this.islamDate = _data["islamDate"] ? new Date(_data["islamDate"].toString()) : <any>undefined;
            this.dateOfEntryKingdom = _data["dateOfEntryKingdom"] ? new Date(_data["dateOfEntryKingdom"].toString()) : <any>undefined;
            this.placeOfBirth = _data["placeOfBirth"];
            this.nationality = _data["nationality"];
            this.previousReligion = _data["previousReligion"];
            this.residenceNumber = _data["residenceNumber"];
            this.passportNumber = _data["passportNumber"];
            this.city = _data["city"];
            this.street = _data["street"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): UserDataForVieweing {
        data = typeof data === 'object' ? data : {};
        let result = new UserDataForVieweing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameBeforeAr"] = this.nameBeforeAr;
        data["nameAfter"] = this.nameAfter;
        data["nameAfterEn"] = this.nameAfterEn;
        data["islamDate"] = this.islamDate ? this.islamDate.toISOString() : <any>undefined;
        data["dateOfEntryKingdom"] = this.dateOfEntryKingdom ? this.dateOfEntryKingdom.toISOString() : <any>undefined;
        data["placeOfBirth"] = this.placeOfBirth;
        data["nationality"] = this.nationality;
        data["previousReligion"] = this.previousReligion;
        data["residenceNumber"] = this.residenceNumber;
        data["passportNumber"] = this.passportNumber;
        data["city"] = this.city;
        data["street"] = this.street;
        data["region"] = this.region;
        return data;
    }
}

export interface IUserDataForVieweing {
    id: number;
    nameBeforeAr?: string | undefined;
    nameAfter?: string | undefined;
    nameAfterEn?: string | undefined;
    islamDate: Date;
    dateOfEntryKingdom: Date;
    placeOfBirth?: string | undefined;
    nationality?: string | undefined;
    previousReligion?: string | undefined;
    residenceNumber?: string | undefined;
    passportNumber?: string | undefined;
    city?: string | undefined;
    street?: string | undefined;
    region?: string | undefined;
}

export class CustomeResponse implements ICustomeResponse {
    code?: string | undefined;

    constructor(data?: ICustomeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CustomeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data;
    }
}

export interface ICustomeResponse {
    code?: string | undefined;
}

export class PrintCardView implements IPrintCardView {
    file?: string | undefined;
    filename?: string | undefined;

    constructor(data?: IPrintCardView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"];
            this.filename = _data["filename"];
        }
    }

    static fromJS(data: any): PrintCardView {
        data = typeof data === 'object' ? data : {};
        let result = new PrintCardView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        data["filename"] = this.filename;
        return data;
    }
}

export interface IPrintCardView {
    file?: string | undefined;
    filename?: string | undefined;
}

export class ViewerPaginationOfStatisticalsOrders implements IViewerPaginationOfStatisticalsOrders {
    paginationList?: StatisticalsOrders[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfStatisticalsOrders) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(StatisticalsOrders.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfStatisticalsOrders {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfStatisticalsOrders();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfStatisticalsOrders {
    paginationList?: StatisticalsOrders[] | undefined;
    originalListListCount: number;
}

export class StatisticalsOrders implements IStatisticalsOrders {
    committeeTitle?: string | undefined;
    ordersNum!: number;
    confirmedOrdersNum!: number;
    notConfirmedOrdersNum!: number;

    constructor(data?: IStatisticalsOrders) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.committeeTitle = _data["committeeTitle"];
            this.ordersNum = _data["ordersNum"];
            this.confirmedOrdersNum = _data["confirmedOrdersNum"];
            this.notConfirmedOrdersNum = _data["notConfirmedOrdersNum"];
        }
    }

    static fromJS(data: any): StatisticalsOrders {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticalsOrders();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["committeeTitle"] = this.committeeTitle;
        data["ordersNum"] = this.ordersNum;
        data["confirmedOrdersNum"] = this.confirmedOrdersNum;
        data["notConfirmedOrdersNum"] = this.notConfirmedOrdersNum;
        return data;
    }
}

export interface IStatisticalsOrders {
    committeeTitle?: string | undefined;
    ordersNum: number;
    confirmedOrdersNum: number;
    notConfirmedOrdersNum: number;
}

export class Settings extends _Model implements ISettings {
    name?: string | undefined;
    code?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): Settings {
        data = typeof data === 'object' ? data : {};
        let result = new Settings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface ISettings extends I_Model {
    name?: string | undefined;
    code?: string | undefined;
    value?: string | undefined;
}

export class UserDto implements IUserDto {
    id!: number;
    passwordHash?: string | undefined;
    userName?: string | undefined;
    mobile?: string | undefined;
    name?: string | undefined;
    identity?: string | undefined;
    email?: string | undefined;
    activeDirectoryUser!: boolean;
    branch?: BranshDto | undefined;
    branchId?: number | undefined;
    userType?: UserType | undefined;
    role?: MainRoleNameId | undefined;
    roleId?: number | undefined;
    signature?: any | undefined;
    committeeId?: number | undefined;
    attachmentBase64?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.passwordHash = _data["passwordHash"];
            this.userName = _data["userName"];
            this.mobile = _data["mobile"];
            this.name = _data["name"];
            this.identity = _data["identity"];
            this.email = _data["email"];
            this.activeDirectoryUser = _data["activeDirectoryUser"];
            this.branch = _data["branch"] ? BranshDto.fromJS(_data["branch"]) : <any>undefined;
            this.branchId = _data["branchId"];
            this.userType = _data["userType"];
            this.role = _data["role"] ? MainRoleNameId.fromJS(_data["role"]) : <any>undefined;
            this.roleId = _data["roleId"];
            this.signature = _data["signature"];
            this.committeeId = _data["committeeId"];
            this.attachmentBase64 = _data["attachmentBase64"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["passwordHash"] = this.passwordHash;
        data["userName"] = this.userName;
        data["mobile"] = this.mobile;
        data["name"] = this.name;
        data["identity"] = this.identity;
        data["email"] = this.email;
        data["activeDirectoryUser"] = this.activeDirectoryUser;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["branchId"] = this.branchId;
        data["userType"] = this.userType;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["roleId"] = this.roleId;
        data["signature"] = this.signature;
        data["committeeId"] = this.committeeId;
        data["attachmentBase64"] = this.attachmentBase64;
        return data;
    }
}

export interface IUserDto {
    id: number;
    passwordHash?: string | undefined;
    userName?: string | undefined;
    mobile?: string | undefined;
    name?: string | undefined;
    identity?: string | undefined;
    email?: string | undefined;
    activeDirectoryUser: boolean;
    branch?: BranshDto | undefined;
    branchId?: number | undefined;
    userType?: UserType | undefined;
    role?: MainRoleNameId | undefined;
    roleId?: number | undefined;
    signature?: any | undefined;
    committeeId?: number | undefined;
    attachmentBase64?: string | undefined;
}

export class ViewerPaginationOfMainUserDto implements IViewerPaginationOfMainUserDto {
    paginationList?: MainUserDto[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfMainUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(MainUserDto.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfMainUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfMainUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfMainUserDto {
    paginationList?: MainUserDto[] | undefined;
    originalListListCount: number;
}

export class MainUserDto implements IMainUserDto {
    id!: number;
    userType!: UserType;
    name?: string | undefined;
    identity?: string | undefined;
    mobile?: string | undefined;
    email?: string | undefined;
    committee?: Committee | undefined;
    department?: Department | undefined;
    attachment?: Attachment | undefined;
    orders?: Order[] | undefined;
    userName?: string | undefined;
    roleTitle?: string | undefined;
    enable!: boolean;

    constructor(data?: IMainUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userType = _data["userType"];
            this.name = _data["name"];
            this.identity = _data["identity"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
            this.committee = _data["committee"] ? Committee.fromJS(_data["committee"]) : <any>undefined;
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.attachment = _data["attachment"] ? Attachment.fromJS(_data["attachment"]) : <any>undefined;
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(Order.fromJS(item));
            }
            this.userName = _data["userName"];
            this.roleTitle = _data["roleTitle"];
            this.enable = _data["enable"];
        }
    }

    static fromJS(data: any): MainUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userType"] = this.userType;
        data["name"] = this.name;
        data["identity"] = this.identity;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["committee"] = this.committee ? this.committee.toJSON() : <any>undefined;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["userName"] = this.userName;
        data["roleTitle"] = this.roleTitle;
        data["enable"] = this.enable;
        return data;
    }
}

export interface IMainUserDto {
    id: number;
    userType: UserType;
    name?: string | undefined;
    identity?: string | undefined;
    mobile?: string | undefined;
    email?: string | undefined;
    committee?: Committee | undefined;
    department?: Department | undefined;
    attachment?: Attachment | undefined;
    orders?: Order[] | undefined;
    userName?: string | undefined;
    roleTitle?: string | undefined;
    enable: boolean;
}

export class FilterData implements IFilterData {
    page!: number;
    pageSize!: number;
    searchTerm?: string | undefined;
    com?: number | undefined;
    dept?: number | undefined;
    brn?: number | undefined;
    role?: number | undefined;
    active!: number;

    constructor(data?: IFilterData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.searchTerm = _data["searchTerm"];
            this.com = _data["com"];
            this.dept = _data["dept"];
            this.brn = _data["brn"];
            this.role = _data["role"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): FilterData {
        data = typeof data === 'object' ? data : {};
        let result = new FilterData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["searchTerm"] = this.searchTerm;
        data["com"] = this.com;
        data["dept"] = this.dept;
        data["brn"] = this.brn;
        data["role"] = this.role;
        data["active"] = this.active;
        return data;
    }
}

export interface IFilterData {
    page: number;
    pageSize: number;
    searchTerm?: string | undefined;
    com?: number | undefined;
    dept?: number | undefined;
    brn?: number | undefined;
    role?: number | undefined;
    active: number;
}

export class UserLoginModel implements IUserLoginModel {
    username!: string;
    password!: string;
    culture?: string | undefined;
    continue!: boolean;

    constructor(data?: IUserLoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.culture = _data["culture"];
            this.continue = _data["continue"];
        }
    }

    static fromJS(data: any): UserLoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["culture"] = this.culture;
        data["continue"] = this.continue;
        return data;
    }
}

export interface IUserLoginModel {
    username: string;
    password: string;
    culture?: string | undefined;
    continue: boolean;
}

export class ChangePasswordModel implements IChangePasswordModel {
    username?: string | undefined;
    oldPassword?: string | undefined;
    newPassword!: string;

    constructor(data?: IChangePasswordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordModel {
    username?: string | undefined;
    oldPassword?: string | undefined;
    newPassword: string;
}

export class AccessToken implements IAccessToken {
    access_token?: string | undefined;
    refresh_token?: string | undefined;
    is_ldap_auth!: boolean;
    is_mobile!: boolean;
    is_vip!: boolean;
    is_factor_auth!: boolean;
    isLocked!: boolean;
    isTemp!: boolean;
    isAdmin!: boolean;
    userTN?: string | undefined;
    userTP?: string | undefined;
    responseMessage?: string | undefined;
    signature_factor_auth!: boolean;
    erP_EmployeeNumber?: string | undefined;
    hasRole!: boolean;

    constructor(data?: IAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"];
            this.refresh_token = _data["refresh_token"];
            this.is_ldap_auth = _data["is_ldap_auth"];
            this.is_mobile = _data["is_mobile"];
            this.is_vip = _data["is_vip"];
            this.is_factor_auth = _data["is_factor_auth"];
            this.isLocked = _data["isLocked"];
            this.isTemp = _data["isTemp"];
            this.isAdmin = _data["isAdmin"];
            this.userTN = _data["userTN"];
            this.userTP = _data["userTP"];
            this.responseMessage = _data["responseMessage"];
            this.signature_factor_auth = _data["signature_factor_auth"];
            this.erP_EmployeeNumber = _data["erP_EmployeeNumber"];
            this.hasRole = _data["hasRole"];
        }
    }

    static fromJS(data: any): AccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new AccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        data["is_ldap_auth"] = this.is_ldap_auth;
        data["is_mobile"] = this.is_mobile;
        data["is_vip"] = this.is_vip;
        data["is_factor_auth"] = this.is_factor_auth;
        data["isLocked"] = this.isLocked;
        data["isTemp"] = this.isTemp;
        data["isAdmin"] = this.isAdmin;
        data["userTN"] = this.userTN;
        data["userTP"] = this.userTP;
        data["responseMessage"] = this.responseMessage;
        data["signature_factor_auth"] = this.signature_factor_auth;
        data["erP_EmployeeNumber"] = this.erP_EmployeeNumber;
        data["hasRole"] = this.hasRole;
        return data;
    }
}

export interface IAccessToken {
    access_token?: string | undefined;
    refresh_token?: string | undefined;
    is_ldap_auth: boolean;
    is_mobile: boolean;
    is_vip: boolean;
    is_factor_auth: boolean;
    isLocked: boolean;
    isTemp: boolean;
    isAdmin: boolean;
    userTN?: string | undefined;
    userTP?: string | undefined;
    responseMessage?: string | undefined;
    signature_factor_auth: boolean;
    erP_EmployeeNumber?: string | undefined;
    hasRole: boolean;
}

export class AddUserResponse implements IAddUserResponse {
    yEryAglcwZnsvNog4GtNh?: string | undefined;

    constructor(data?: IAddUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yEryAglcwZnsvNog4GtNh = _data["yEryAglcwZnsvNog4GtNh"];
        }
    }

    static fromJS(data: any): AddUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yEryAglcwZnsvNog4GtNh"] = this.yEryAglcwZnsvNog4GtNh;
        return data;
    }
}

export interface IAddUserResponse {
    yEryAglcwZnsvNog4GtNh?: string | undefined;
}

export class ViewerPaginationOfWitness implements IViewerPaginationOfWitness {
    paginationList?: Witness[] | undefined;
    originalListListCount!: number;

    constructor(data?: IViewerPaginationOfWitness) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paginationList"])) {
                this.paginationList = [] as any;
                for (let item of _data["paginationList"])
                    this.paginationList!.push(Witness.fromJS(item));
            }
            this.originalListListCount = _data["originalListListCount"];
        }
    }

    static fromJS(data: any): ViewerPaginationOfWitness {
        data = typeof data === 'object' ? data : {};
        let result = new ViewerPaginationOfWitness();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paginationList)) {
            data["paginationList"] = [];
            for (let item of this.paginationList)
                data["paginationList"].push(item.toJSON());
        }
        data["originalListListCount"] = this.originalListListCount;
        return data;
    }
}

export interface IViewerPaginationOfWitness {
    paginationList?: Witness[] | undefined;
    originalListListCount: number;
}

export class GenericResultOfWitnessDto implements IGenericResultOfWitnessDto {
    data?: WitnessDto | undefined;
    message?: string | undefined;
    status!: number;

    constructor(data?: IGenericResultOfWitnessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? WitnessDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GenericResultOfWitnessDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenericResultOfWitnessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["status"] = this.status;
        return data;
    }
}

export interface IGenericResultOfWitnessDto {
    data?: WitnessDto | undefined;
    message?: string | undefined;
    status: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}